<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>new_backend.Controller API documentation</title>
<meta name="description" content="Backend - Controller Class
Created on Tue February 15, 2022 …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>new_backend.Controller</code></h1>
</header>
<section id="section-intro">
<p>Backend - Controller Class
Created on Tue February 15, 2022</p>
<p>Summary: The Controller class is a static base class that implements control over the vehicles in the
Simulation. This class provides the basic interface and functions that all Controller classes can use.
Ego, Intersection, and Freeway controllers are derived from this base class</p>
<h2 id="references">References</h2>
<p>Helpers
Vehicle</p>
<p>Referenced By:
EgoController
FreewayController
IntersectionController
TestExperiment</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Backend - Controller Class
Created on Tue February 15, 2022

Summary: The Controller class is a static base class that implements control over the vehicles in the
    Simulation. This class provides the basic interface and functions that all Controller classes can use.
    Ego, Intersection, and Freeway controllers are derived from this base class

References:
    Helpers
    Vehicle

Referenced By:
    EgoController
    FreewayController
    IntersectionController
    TestExperiment

&#34;&#34;&#34;

# Local Imports
from Helpers import to_numpy_vector, smooth_path, VehicleType
from Vehicle import Vehicle

# Library Imports
import carla
import heapq
import numpy as np
import random
from typing import List, Tuple

# Global variable to define how far apart waypoints on the road network should be
WAYPOINT_SEPARATION = 15

# Global constant that dictates how strongly speed affects the Pure Pursuit lookahead distance
SPEED_CONSTANT = 0.1

# Global constant that dictates how much additional stopping distance the vehicle gains per kilometer per hour
STOP_DISTANCE_FACTOR = 0.25


class Controller:

    @staticmethod
    def update_control(current_vehicle: Vehicle) -&gt; None:
        &#34;&#34;&#34;
        Abstract function that dictates how a derived Controller class should update the Vehicles control.

        All derived controller classes must implement this method. The update_control method takes in a
        vehicle and determines what control parameters should be passed to it to update its acceleration
        and steering in the Carla simulation. This function will call apply_control on the current
        vehicle to steer the vehicle in the correct direction.

        :param current_vehicle: the Vehicle object to which updated control needs to be applied
        :return: None
        &#34;&#34;&#34;
        pass

    @staticmethod
    def generate_path(current_vehicle: Vehicle, starting_point: carla.Waypoint, ending_point: carla.Waypoint) -&gt; None:
        &#34;&#34;&#34;
        Calculates the shortest trajectory between the starting endpoint and ending waypoint of the Vehicle&#39;s route.

        Uses A* pathfinding algorithm to determine the shortest path between the starting waypoint and
        the ending waypoint. All paths will follow Carla&#39;s autogenerated waypoints that define the
        valid road network. The path is guaranteed to take the shortest number of jumps between waypoints,
        however there is no guarantee that the path will be the shortest in terms of absolute distance.

        :param current_vehicle: the Vehicle object that the path needs to be generated for
        :param starting_point: the carla.Waypoint object that the vehicle will be starting at
        :param ending_point: the carla.Waypoint object that the vehicle will be ending at
        :return: None
        &#34;&#34;&#34;

        # Location of the destination waypoint
        destination: np.array = to_numpy_vector(ending_point.transform.location)

        # List of tuples containing each explored waypoint, the current distance to that waypoint,
        # and the index of their previous waypoint along the path
        explored_list: List[Tuple[carla.Waypoint, int]] = []

        # List of Tuples used as a Priority Queue. The first int is the straight line distance
        # between the waypoint and the destination. The second Tuple contains the waypoint
        # and the index of the previous waypoint in the path
        potential_list: List[Tuple[int, Tuple[carla.Waypoint, int]]] = []

        # Add the initial point to the potential_list
        heapq.heappush(potential_list, (0, (starting_point, -1)))

        # Main A* loop
        while True:

            # Grab the current waypoint and previous index
            _, (current_waypoint, current_previous_index) = heapq.heappop(potential_list)

            # Add them to the explored list
            explored_list.append((current_waypoint, current_previous_index))

            # If the search is over, backtrack to build the path
            if Controller._end_of_search(current_waypoint, ending_point):
                waypoints = Controller._backtrack_path(explored_list)
                current_vehicle.waypoints = waypoints
                current_vehicle.trajectory = smooth_path(waypoints)
                return

            # Check all the potential next waypoints and add them to the potential list
            # if they haven&#39;t already been explored
            potential_new_waypoints = Controller._get_next_waypoints(current_waypoint)
            already_explored_waypoint_ids = [x[0].id for x in explored_list]
            for potential_new_waypoint in potential_new_waypoints:
                if potential_new_waypoint.id not in already_explored_waypoint_ids:
                    distance_to_destination = np.linalg.norm(to_numpy_vector(potential_new_waypoint.transform.location)
                                                             - destination)
                    heapq.heappush(potential_list,
                                   (distance_to_destination + random.random(),
                                    (potential_new_waypoint, len(explored_list) - 1)))

            # Handle the case of no path between the starting and ending waypoint
            if len(potential_list) == 0:
                raise Exception(f&#34;Unable to find path between waypoints {starting_point.id} and {ending_point.id}&#34;)

    @staticmethod
    def steering_control(current_vehicle: Vehicle) -&gt; Tuple[float, bool]:
        &#34;&#34;&#34;
        Implements path following using the Pure Pursuit Path Tracking algorithm.

        Link to a paper on the subject can be found here:
        https://www.ri.cmu.edu/publications/implementation-of-the-pure-pursuit-path-tracking-algorithm/
        Determines what steering angle the vehicle needs to remain on the path outlined by its waypoints.
        Chooses a lookahead distance based on the vehicle&#39;s current speed and identifies the waypoint
        that is closest to that lookahead distance. Then, calculates the curve that connects the Vehicle&#39;s
        current location to that destination waypoint. The inverse tangent of the curve can then be
        taken to determine the steering angle needed.

        :param current_vehicle: a Vehicle object representing the vehicle to be controlled
        :return: a Tuple where the first element is a float representing the steering angle in radians
                 (bounded between -1 and 1) and the second element is if the Vehicle has reached
                 the end of the path
        &#34;&#34;&#34;

        # Get the current location and forward facing vector of the vehicle
        current_location: np.array = current_vehicle.get_location_vector(dims=2)
        forward_facing_vector: np.array = to_numpy_vector(
            current_vehicle.carla_vehicle.get_transform().get_forward_vector(), dims=2)
        unit_forward_facing_vector: np.array = forward_facing_vector / np.linalg.norm(forward_facing_vector)

        # Find the closest waypoint to the vehicles current location
        trajectory: List[carla.Transform] = current_vehicle.trajectory
        trajectory_point_distances: List[np.array] = [
            np.linalg.norm(to_numpy_vector(x.location, dims=2) - current_location)
            for x in trajectory]
        nearest_trajectory_point_index = np.argmin(trajectory_point_distances)

        # Determine what our lookahead distance should be
        current_forward_speed = np.linalg.norm(to_numpy_vector(current_vehicle.carla_vehicle.get_velocity()))
        lookahead_distance = 4 + current_forward_speed * SPEED_CONSTANT

        # Find the next waypoint that is at least lookahead distance away, or at the end of the path
        current_distance = 0
        index = nearest_trajectory_point_index + 1
        while current_distance &lt; lookahead_distance and index &lt; len(trajectory):
            current_distance += np.linalg.norm(
                to_numpy_vector(trajectory[index].location) - to_numpy_vector(trajectory[index - 1].location))
            index += 1

        # Stop the car if we&#39;ve reached the end of the path
        if index &gt;= len(trajectory):
            return 0.0, True

        # Identify our new goal waypoint
        goal_trajectory_point = trajectory[index]
        distance_from_current_location_to_goal = trajectory_point_distances[index]

        # Calculate the angle between the vehicles forward facing vector and the distance vector between the
        # car and goal waypoint
        distance_vector = to_numpy_vector(goal_trajectory_point.location, dims=2) - current_location
        unit_distance_vector = distance_vector / np.linalg.norm(distance_vector)
        theta = np.arctan2(unit_distance_vector[1], unit_distance_vector[0]) - \
            np.arctan2(unit_forward_facing_vector[1], unit_forward_facing_vector[0])

        # Lastly, get the length of the vehicle and calculate the steering angle
        vehicle_length = current_vehicle.carla_vehicle.bounding_box.extent.y * 2
        steering_angle = np.arctan2(2 * vehicle_length * np.sin(theta), distance_from_current_location_to_goal)

        return steering_angle, False

    @staticmethod
    def throttle_control(current_vehicle: Vehicle) -&gt; float:
        &#34;&#34;&#34;
        Applies throttle control to the vehicle based on its current setting.

        The different modes that a vehicle can operate in are a &#34;target_location&#34;, &#34;target_speed&#34;, or
        &#34;target_distance&#34;.

        In target_location mode, the vehicle will accelerate maintain its target speed
        until it is within a certain distance of its target location. Then, it will brake to smoothly
        stop at that location. This mode is activated if the current_vehicle has a valid target location
        and the vehicle is within its pre-defined breaking distance.

        In target_distance mode, the vehicle will accelerate or decelerate as necessary to maintain a
        target distance from the vehicle in-front of it. This mode is activated if there is a vehicle in front
        of the current vehicle within 1.2 times the current vehicle&#39;s safety distance. This mode can never be
        activated for a lead vehicle.

        In target_speed mode, the vehicle will accelerate up to its target speed and then apply the acceleration
        necessary to maintain that speed. This mode will be activated if neither of the other modes apply.

        :param current_vehicle: the Vehicle object to calculate the throttle for
        :return: a float representing the throttle to be applied to the vehicle (between -1 and 1)
        &#34;&#34;&#34;

        # Apply the target location control if necessary
        if current_vehicle.target_location is not None:
            current_distance = np.sum(to_numpy_vector(current_vehicle.target_location) -
                                      current_vehicle.get_location_vector())
            if current_distance &lt;= current_vehicle.breaking_distance:
                return Controller._throttle_target_location(current_vehicle)

        # Apply the target distance control if necessary
        if current_vehicle.type_id != VehicleType.LEAD:
            car_in_front, current_distance = current_vehicle.check_vehicle_in_front()
            if car_in_front:
                return Controller._throttle_target_distance(current_vehicle, current_distance)

        # Lastly, apply target speed control
        return Controller._throttle_target_speed(current_vehicle)

    @staticmethod
    def _obey_traffic_light(current_vehicle: Vehicle) -&gt; Tuple[bool, carla.VehicleControl]:
        &#34;&#34;&#34;
        Determines if the Vehicle needs to change its control to obey a traffic light.

        Checks if the Vehicle is currently being affected by a traffic light, and
        provides a new carla.VehicleControl object that will allow the Vehicle to
        obey the light. Designed to be called either within or after update_control.

        :param current_vehicle: the Vehicle object that will be checked for traffic lights
        :return: a tuple of (bool, carla.VehicleControl). The first element will be True if the Vehicle
                 is being affected by a traffic light. If True, the second element will contain a
                 new carla.VehicleControl that should be applied to the Vehicle.
        &#34;&#34;&#34;

        # is_changed = True
        # control = self.VehicleControl
        # curr_car_speed = get_vehicle_speed(current_vehicle)
        #
        # traffic_light_state = carla.get_traffic_light_state(current_vehicle)
        #
        # # if the traffic light is red and the vehicle is moving, stop
        # if (traffic_light_state == &#39;Red&#39; or traffic_light_state == &#39;Yellow&#39;) and curr_car_speed &gt; 0.0:
        #     control = carla.VehicleControl(throttle = 0.0,steer=steer,brake = 1.0) # stop car
        # # if the traffic light is green or yellow and the vehicle is not moving, start moving
        # elif traffic_light_state == &#39;Green&#39; and curr_car_speed == 0.0:
        #     control = carla.VehicleControl(throttle = 1.0,steer=steer,brake = 0.0) # start car
        # else:
        #     is_changed = False
        #
        # return Tuple[is_changed, control]

    @staticmethod
    def _avoid_collisions(current_vehicle: Vehicle) -&gt; Tuple[bool, carla.VehicleControl]:
        &#34;&#34;&#34;
        Determines if the Vehicle needs to change its control to avoid a collision.

        Checks if the Vehicle is nearing a collision with another nearby Vehicle (to the left or right),
        and provides a new carla.VehicleControl object that will allow the Vehicle to avoid the
        collision. Designed to be called either within or after update_control.

        :param current_vehicle: the Vehicle object that will be checked for near collisions
        :return: a tuple of (bool, carla.VehicleControl). The first element will be True if the Vehicle
                 needs to avoid a collision. If True, the second element will contain a
                 new carla.VehicleControl that should be applied to the Vehicle.
        &#34;&#34;&#34;
        pass

    @staticmethod
    def _end_of_search(current_waypoint: carla.Waypoint, ending_waypoint: carla.Waypoint) -&gt; bool:
        &#34;&#34;&#34;
        Determines if the A* search has successfully arrived at its destination point.

        To finish the search, the current waypoint must be less than half of WAYPOINT_SEPARATION
        away from the ending waypoint

        :param current_waypoint: a carla.Waypoint representing the current waypoint in the search
        :param ending_waypoint: a carla.Waypoint representing the ending waypoint in the search
        :return: a bool representing if the search is finished
        &#34;&#34;&#34;

        current_location = current_waypoint.transform.location
        ending_location = ending_waypoint.transform.location
        separation = current_location.distance(ending_location)
        if separation &lt; WAYPOINT_SEPARATION / 2:
            return True
        return False

    @staticmethod
    def _backtrack_path(explored_list: List[Tuple[carla.Waypoint, int]]) -&gt; List[carla.Transform]:
        &#34;&#34;&#34;
        Backtracks the explored path to build the shortest path from the initial point to the final destination.

        :param explored_list: a List of Tuples where the first element is a carla.Waypoint object
                              and the second element is the list index of the ancestor waypoint
        :return: a list of carla.Transforms representing the completed path
        &#34;&#34;&#34;

        # Initialize the path and the ending locations
        path: List[carla.Waypoint] = []
        current_waypoint, current_index = explored_list[-1]

        # Continue backtracking until the first waypoint is reached
        while current_index != -1:
            path.append(current_waypoint.transform)
            current_waypoint, current_index = explored_list[current_index]

        return path[::-1]

    @staticmethod
    def _get_next_waypoints(current_waypoint: carla.Waypoint) -&gt; List[carla.Waypoint]:
        &#34;&#34;&#34;
        Gets a list of all the possible next waypoints from the current waypoint

        :param current_waypoint: a carla.Waypoint representing the current waypoint
        :return: a List of carla.Waypoints
        &#34;&#34;&#34;

        # Get all the possible next waypoints
        new_potential_waypoints: List[carla.Waypoint] = current_waypoint.next(WAYPOINT_SEPARATION)

        # Also add additional waypoints if the current waypoint is an intersection
        if current_waypoint.is_junction:
            junction_points = current_waypoint.get_junction().get_waypoints(carla.LaneType.Any)
            for pair in junction_points:
                if pair[0].id == current_waypoint.id:
                    new_potential_waypoints.append(pair[1])
                elif pair[1].id == current_waypoint.id:
                    new_potential_waypoints.append(pair[0])

        return new_potential_waypoints

    @staticmethod
    def _throttle_target_location(current_vehicle: Vehicle) -&gt; float:
        &#34;&#34;&#34;
        Determines what throttle the Vehicle needs to stop at its target location.

        Uses the current speed of the vehicle and the distance to the target location to determine
        how much breaking needs to be applied to stop the vehicle. If the car is moving too slowly
        and breaking is not necessary, light throttle will be applied.

        :param current_vehicle: the Vehicle to calculate the throttle for
        :return: the throttle value to apply to the vehicle (between -1 and 1)
        &#34;&#34;&#34;

        # Calculate the distance to the target location
        distance_to_location = np.sum(to_numpy_vector(current_vehicle.target_location, dims=2) -
                                      current_vehicle.get_current_position())

        # Calculate the vehicle&#39;s stopping distance
        stopping_distance = current_vehicle.get_current_speed() * STOP_DISTANCE_FACTOR

        # Pass the difference between the distance to the location
        # and the current stopping distance to the PID controller
        throttle = current_vehicle.location_pid_controller(distance_to_location - stopping_distance)
        return max(min(throttle, 1), -1)

    @staticmethod
    def _throttle_target_distance(current_vehicle: Vehicle, current_distance: float) -&gt; float:
        &#34;&#34;&#34;
        Determines what throttle the Vehicle needs to remain a target_distance away from the Vehicle in front.

        The Vehicle will accelerate until it is within the target distance of the Vehicle in front of it.
        Then, the Vehicle will alternate accelerating and breaking to maintain a constant distance from
        the vehicle in front.

        :param current_vehicle: the Vehicle to calculate the throttle for
        :param current_distance: the current distance between the Vehicle and the Vehicle in front
        :return: the throttle value to apply to the vehicle (between -1 and 1)
        &#34;&#34;&#34;
        # Subtract by the Vehicle size to account for the bumper to bumper distance
        throttle = current_vehicle.distance_pid_controller(current_vehicle.target_distance - current_distance -
                                                           current_vehicle.get_vehicle_size().y)
        return max(min(throttle, 1), -1)

    @staticmethod
    def _throttle_target_speed(current_vehicle: Vehicle) -&gt; float:
        &#34;&#34;&#34;
        Determines what throttle the Vehicle needs to maintain a constant speed.

        The Vehicle will accelerate or decelerate as needed to maintain the constant target_speed

        :param current_vehicle: the Vehicle to calculate the throttle for
        :return: the throttle value to apply to the Vehicle (between -1 and 1)
        &#34;&#34;&#34;

        throttle = current_vehicle.speed_pid_controller(current_vehicle.target_speed -
                                                        current_vehicle.get_current_speed())
        return max(min(throttle, 1), -1)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="new_backend.Controller.Controller"><code class="flex name class">
<span>class <span class="ident">Controller</span></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Controller:

    @staticmethod
    def update_control(current_vehicle: Vehicle) -&gt; None:
        &#34;&#34;&#34;
        Abstract function that dictates how a derived Controller class should update the Vehicles control.

        All derived controller classes must implement this method. The update_control method takes in a
        vehicle and determines what control parameters should be passed to it to update its acceleration
        and steering in the Carla simulation. This function will call apply_control on the current
        vehicle to steer the vehicle in the correct direction.

        :param current_vehicle: the Vehicle object to which updated control needs to be applied
        :return: None
        &#34;&#34;&#34;
        pass

    @staticmethod
    def generate_path(current_vehicle: Vehicle, starting_point: carla.Waypoint, ending_point: carla.Waypoint) -&gt; None:
        &#34;&#34;&#34;
        Calculates the shortest trajectory between the starting endpoint and ending waypoint of the Vehicle&#39;s route.

        Uses A* pathfinding algorithm to determine the shortest path between the starting waypoint and
        the ending waypoint. All paths will follow Carla&#39;s autogenerated waypoints that define the
        valid road network. The path is guaranteed to take the shortest number of jumps between waypoints,
        however there is no guarantee that the path will be the shortest in terms of absolute distance.

        :param current_vehicle: the Vehicle object that the path needs to be generated for
        :param starting_point: the carla.Waypoint object that the vehicle will be starting at
        :param ending_point: the carla.Waypoint object that the vehicle will be ending at
        :return: None
        &#34;&#34;&#34;

        # Location of the destination waypoint
        destination: np.array = to_numpy_vector(ending_point.transform.location)

        # List of tuples containing each explored waypoint, the current distance to that waypoint,
        # and the index of their previous waypoint along the path
        explored_list: List[Tuple[carla.Waypoint, int]] = []

        # List of Tuples used as a Priority Queue. The first int is the straight line distance
        # between the waypoint and the destination. The second Tuple contains the waypoint
        # and the index of the previous waypoint in the path
        potential_list: List[Tuple[int, Tuple[carla.Waypoint, int]]] = []

        # Add the initial point to the potential_list
        heapq.heappush(potential_list, (0, (starting_point, -1)))

        # Main A* loop
        while True:

            # Grab the current waypoint and previous index
            _, (current_waypoint, current_previous_index) = heapq.heappop(potential_list)

            # Add them to the explored list
            explored_list.append((current_waypoint, current_previous_index))

            # If the search is over, backtrack to build the path
            if Controller._end_of_search(current_waypoint, ending_point):
                waypoints = Controller._backtrack_path(explored_list)
                current_vehicle.waypoints = waypoints
                current_vehicle.trajectory = smooth_path(waypoints)
                return

            # Check all the potential next waypoints and add them to the potential list
            # if they haven&#39;t already been explored
            potential_new_waypoints = Controller._get_next_waypoints(current_waypoint)
            already_explored_waypoint_ids = [x[0].id for x in explored_list]
            for potential_new_waypoint in potential_new_waypoints:
                if potential_new_waypoint.id not in already_explored_waypoint_ids:
                    distance_to_destination = np.linalg.norm(to_numpy_vector(potential_new_waypoint.transform.location)
                                                             - destination)
                    heapq.heappush(potential_list,
                                   (distance_to_destination + random.random(),
                                    (potential_new_waypoint, len(explored_list) - 1)))

            # Handle the case of no path between the starting and ending waypoint
            if len(potential_list) == 0:
                raise Exception(f&#34;Unable to find path between waypoints {starting_point.id} and {ending_point.id}&#34;)

    @staticmethod
    def steering_control(current_vehicle: Vehicle) -&gt; Tuple[float, bool]:
        &#34;&#34;&#34;
        Implements path following using the Pure Pursuit Path Tracking algorithm.

        Link to a paper on the subject can be found here:
        https://www.ri.cmu.edu/publications/implementation-of-the-pure-pursuit-path-tracking-algorithm/
        Determines what steering angle the vehicle needs to remain on the path outlined by its waypoints.
        Chooses a lookahead distance based on the vehicle&#39;s current speed and identifies the waypoint
        that is closest to that lookahead distance. Then, calculates the curve that connects the Vehicle&#39;s
        current location to that destination waypoint. The inverse tangent of the curve can then be
        taken to determine the steering angle needed.

        :param current_vehicle: a Vehicle object representing the vehicle to be controlled
        :return: a Tuple where the first element is a float representing the steering angle in radians
                 (bounded between -1 and 1) and the second element is if the Vehicle has reached
                 the end of the path
        &#34;&#34;&#34;

        # Get the current location and forward facing vector of the vehicle
        current_location: np.array = current_vehicle.get_location_vector(dims=2)
        forward_facing_vector: np.array = to_numpy_vector(
            current_vehicle.carla_vehicle.get_transform().get_forward_vector(), dims=2)
        unit_forward_facing_vector: np.array = forward_facing_vector / np.linalg.norm(forward_facing_vector)

        # Find the closest waypoint to the vehicles current location
        trajectory: List[carla.Transform] = current_vehicle.trajectory
        trajectory_point_distances: List[np.array] = [
            np.linalg.norm(to_numpy_vector(x.location, dims=2) - current_location)
            for x in trajectory]
        nearest_trajectory_point_index = np.argmin(trajectory_point_distances)

        # Determine what our lookahead distance should be
        current_forward_speed = np.linalg.norm(to_numpy_vector(current_vehicle.carla_vehicle.get_velocity()))
        lookahead_distance = 4 + current_forward_speed * SPEED_CONSTANT

        # Find the next waypoint that is at least lookahead distance away, or at the end of the path
        current_distance = 0
        index = nearest_trajectory_point_index + 1
        while current_distance &lt; lookahead_distance and index &lt; len(trajectory):
            current_distance += np.linalg.norm(
                to_numpy_vector(trajectory[index].location) - to_numpy_vector(trajectory[index - 1].location))
            index += 1

        # Stop the car if we&#39;ve reached the end of the path
        if index &gt;= len(trajectory):
            return 0.0, True

        # Identify our new goal waypoint
        goal_trajectory_point = trajectory[index]
        distance_from_current_location_to_goal = trajectory_point_distances[index]

        # Calculate the angle between the vehicles forward facing vector and the distance vector between the
        # car and goal waypoint
        distance_vector = to_numpy_vector(goal_trajectory_point.location, dims=2) - current_location
        unit_distance_vector = distance_vector / np.linalg.norm(distance_vector)
        theta = np.arctan2(unit_distance_vector[1], unit_distance_vector[0]) - \
            np.arctan2(unit_forward_facing_vector[1], unit_forward_facing_vector[0])

        # Lastly, get the length of the vehicle and calculate the steering angle
        vehicle_length = current_vehicle.carla_vehicle.bounding_box.extent.y * 2
        steering_angle = np.arctan2(2 * vehicle_length * np.sin(theta), distance_from_current_location_to_goal)

        return steering_angle, False

    @staticmethod
    def throttle_control(current_vehicle: Vehicle) -&gt; float:
        &#34;&#34;&#34;
        Applies throttle control to the vehicle based on its current setting.

        The different modes that a vehicle can operate in are a &#34;target_location&#34;, &#34;target_speed&#34;, or
        &#34;target_distance&#34;.

        In target_location mode, the vehicle will accelerate maintain its target speed
        until it is within a certain distance of its target location. Then, it will brake to smoothly
        stop at that location. This mode is activated if the current_vehicle has a valid target location
        and the vehicle is within its pre-defined breaking distance.

        In target_distance mode, the vehicle will accelerate or decelerate as necessary to maintain a
        target distance from the vehicle in-front of it. This mode is activated if there is a vehicle in front
        of the current vehicle within 1.2 times the current vehicle&#39;s safety distance. This mode can never be
        activated for a lead vehicle.

        In target_speed mode, the vehicle will accelerate up to its target speed and then apply the acceleration
        necessary to maintain that speed. This mode will be activated if neither of the other modes apply.

        :param current_vehicle: the Vehicle object to calculate the throttle for
        :return: a float representing the throttle to be applied to the vehicle (between -1 and 1)
        &#34;&#34;&#34;

        # Apply the target location control if necessary
        if current_vehicle.target_location is not None:
            current_distance = np.sum(to_numpy_vector(current_vehicle.target_location) -
                                      current_vehicle.get_location_vector())
            if current_distance &lt;= current_vehicle.breaking_distance:
                return Controller._throttle_target_location(current_vehicle)

        # Apply the target distance control if necessary
        if current_vehicle.type_id != VehicleType.LEAD:
            car_in_front, current_distance = current_vehicle.check_vehicle_in_front()
            if car_in_front:
                return Controller._throttle_target_distance(current_vehicle, current_distance)

        # Lastly, apply target speed control
        return Controller._throttle_target_speed(current_vehicle)

    @staticmethod
    def _obey_traffic_light(current_vehicle: Vehicle) -&gt; Tuple[bool, carla.VehicleControl]:
        &#34;&#34;&#34;
        Determines if the Vehicle needs to change its control to obey a traffic light.

        Checks if the Vehicle is currently being affected by a traffic light, and
        provides a new carla.VehicleControl object that will allow the Vehicle to
        obey the light. Designed to be called either within or after update_control.

        :param current_vehicle: the Vehicle object that will be checked for traffic lights
        :return: a tuple of (bool, carla.VehicleControl). The first element will be True if the Vehicle
                 is being affected by a traffic light. If True, the second element will contain a
                 new carla.VehicleControl that should be applied to the Vehicle.
        &#34;&#34;&#34;

        # is_changed = True
        # control = self.VehicleControl
        # curr_car_speed = get_vehicle_speed(current_vehicle)
        #
        # traffic_light_state = carla.get_traffic_light_state(current_vehicle)
        #
        # # if the traffic light is red and the vehicle is moving, stop
        # if (traffic_light_state == &#39;Red&#39; or traffic_light_state == &#39;Yellow&#39;) and curr_car_speed &gt; 0.0:
        #     control = carla.VehicleControl(throttle = 0.0,steer=steer,brake = 1.0) # stop car
        # # if the traffic light is green or yellow and the vehicle is not moving, start moving
        # elif traffic_light_state == &#39;Green&#39; and curr_car_speed == 0.0:
        #     control = carla.VehicleControl(throttle = 1.0,steer=steer,brake = 0.0) # start car
        # else:
        #     is_changed = False
        #
        # return Tuple[is_changed, control]

    @staticmethod
    def _avoid_collisions(current_vehicle: Vehicle) -&gt; Tuple[bool, carla.VehicleControl]:
        &#34;&#34;&#34;
        Determines if the Vehicle needs to change its control to avoid a collision.

        Checks if the Vehicle is nearing a collision with another nearby Vehicle (to the left or right),
        and provides a new carla.VehicleControl object that will allow the Vehicle to avoid the
        collision. Designed to be called either within or after update_control.

        :param current_vehicle: the Vehicle object that will be checked for near collisions
        :return: a tuple of (bool, carla.VehicleControl). The first element will be True if the Vehicle
                 needs to avoid a collision. If True, the second element will contain a
                 new carla.VehicleControl that should be applied to the Vehicle.
        &#34;&#34;&#34;
        pass

    @staticmethod
    def _end_of_search(current_waypoint: carla.Waypoint, ending_waypoint: carla.Waypoint) -&gt; bool:
        &#34;&#34;&#34;
        Determines if the A* search has successfully arrived at its destination point.

        To finish the search, the current waypoint must be less than half of WAYPOINT_SEPARATION
        away from the ending waypoint

        :param current_waypoint: a carla.Waypoint representing the current waypoint in the search
        :param ending_waypoint: a carla.Waypoint representing the ending waypoint in the search
        :return: a bool representing if the search is finished
        &#34;&#34;&#34;

        current_location = current_waypoint.transform.location
        ending_location = ending_waypoint.transform.location
        separation = current_location.distance(ending_location)
        if separation &lt; WAYPOINT_SEPARATION / 2:
            return True
        return False

    @staticmethod
    def _backtrack_path(explored_list: List[Tuple[carla.Waypoint, int]]) -&gt; List[carla.Transform]:
        &#34;&#34;&#34;
        Backtracks the explored path to build the shortest path from the initial point to the final destination.

        :param explored_list: a List of Tuples where the first element is a carla.Waypoint object
                              and the second element is the list index of the ancestor waypoint
        :return: a list of carla.Transforms representing the completed path
        &#34;&#34;&#34;

        # Initialize the path and the ending locations
        path: List[carla.Waypoint] = []
        current_waypoint, current_index = explored_list[-1]

        # Continue backtracking until the first waypoint is reached
        while current_index != -1:
            path.append(current_waypoint.transform)
            current_waypoint, current_index = explored_list[current_index]

        return path[::-1]

    @staticmethod
    def _get_next_waypoints(current_waypoint: carla.Waypoint) -&gt; List[carla.Waypoint]:
        &#34;&#34;&#34;
        Gets a list of all the possible next waypoints from the current waypoint

        :param current_waypoint: a carla.Waypoint representing the current waypoint
        :return: a List of carla.Waypoints
        &#34;&#34;&#34;

        # Get all the possible next waypoints
        new_potential_waypoints: List[carla.Waypoint] = current_waypoint.next(WAYPOINT_SEPARATION)

        # Also add additional waypoints if the current waypoint is an intersection
        if current_waypoint.is_junction:
            junction_points = current_waypoint.get_junction().get_waypoints(carla.LaneType.Any)
            for pair in junction_points:
                if pair[0].id == current_waypoint.id:
                    new_potential_waypoints.append(pair[1])
                elif pair[1].id == current_waypoint.id:
                    new_potential_waypoints.append(pair[0])

        return new_potential_waypoints

    @staticmethod
    def _throttle_target_location(current_vehicle: Vehicle) -&gt; float:
        &#34;&#34;&#34;
        Determines what throttle the Vehicle needs to stop at its target location.

        Uses the current speed of the vehicle and the distance to the target location to determine
        how much breaking needs to be applied to stop the vehicle. If the car is moving too slowly
        and breaking is not necessary, light throttle will be applied.

        :param current_vehicle: the Vehicle to calculate the throttle for
        :return: the throttle value to apply to the vehicle (between -1 and 1)
        &#34;&#34;&#34;

        # Calculate the distance to the target location
        distance_to_location = np.sum(to_numpy_vector(current_vehicle.target_location, dims=2) -
                                      current_vehicle.get_current_position())

        # Calculate the vehicle&#39;s stopping distance
        stopping_distance = current_vehicle.get_current_speed() * STOP_DISTANCE_FACTOR

        # Pass the difference between the distance to the location
        # and the current stopping distance to the PID controller
        throttle = current_vehicle.location_pid_controller(distance_to_location - stopping_distance)
        return max(min(throttle, 1), -1)

    @staticmethod
    def _throttle_target_distance(current_vehicle: Vehicle, current_distance: float) -&gt; float:
        &#34;&#34;&#34;
        Determines what throttle the Vehicle needs to remain a target_distance away from the Vehicle in front.

        The Vehicle will accelerate until it is within the target distance of the Vehicle in front of it.
        Then, the Vehicle will alternate accelerating and breaking to maintain a constant distance from
        the vehicle in front.

        :param current_vehicle: the Vehicle to calculate the throttle for
        :param current_distance: the current distance between the Vehicle and the Vehicle in front
        :return: the throttle value to apply to the vehicle (between -1 and 1)
        &#34;&#34;&#34;
        # Subtract by the Vehicle size to account for the bumper to bumper distance
        throttle = current_vehicle.distance_pid_controller(current_vehicle.target_distance - current_distance -
                                                           current_vehicle.get_vehicle_size().y)
        return max(min(throttle, 1), -1)

    @staticmethod
    def _throttle_target_speed(current_vehicle: Vehicle) -&gt; float:
        &#34;&#34;&#34;
        Determines what throttle the Vehicle needs to maintain a constant speed.

        The Vehicle will accelerate or decelerate as needed to maintain the constant target_speed

        :param current_vehicle: the Vehicle to calculate the throttle for
        :return: the throttle value to apply to the Vehicle (between -1 and 1)
        &#34;&#34;&#34;

        throttle = current_vehicle.speed_pid_controller(current_vehicle.target_speed -
                                                        current_vehicle.get_current_speed())
        return max(min(throttle, 1), -1)</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="new_backend.Controller.Controller.generate_path"><code class="name flex">
<span>def <span class="ident">generate_path</span></span>(<span>current_vehicle: Vehicle.Vehicle, starting_point: carla.libcarla.Waypoint, ending_point: carla.libcarla.Waypoint) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the shortest trajectory between the starting endpoint and ending waypoint of the Vehicle's route.</p>
<p>Uses A* pathfinding algorithm to determine the shortest path between the starting waypoint and
the ending waypoint. All paths will follow Carla's autogenerated waypoints that define the
valid road network. The path is guaranteed to take the shortest number of jumps between waypoints,
however there is no guarantee that the path will be the shortest in terms of absolute distance.</p>
<p>:param current_vehicle: the Vehicle object that the path needs to be generated for
:param starting_point: the carla.Waypoint object that the vehicle will be starting at
:param ending_point: the carla.Waypoint object that the vehicle will be ending at
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def generate_path(current_vehicle: Vehicle, starting_point: carla.Waypoint, ending_point: carla.Waypoint) -&gt; None:
    &#34;&#34;&#34;
    Calculates the shortest trajectory between the starting endpoint and ending waypoint of the Vehicle&#39;s route.

    Uses A* pathfinding algorithm to determine the shortest path between the starting waypoint and
    the ending waypoint. All paths will follow Carla&#39;s autogenerated waypoints that define the
    valid road network. The path is guaranteed to take the shortest number of jumps between waypoints,
    however there is no guarantee that the path will be the shortest in terms of absolute distance.

    :param current_vehicle: the Vehicle object that the path needs to be generated for
    :param starting_point: the carla.Waypoint object that the vehicle will be starting at
    :param ending_point: the carla.Waypoint object that the vehicle will be ending at
    :return: None
    &#34;&#34;&#34;

    # Location of the destination waypoint
    destination: np.array = to_numpy_vector(ending_point.transform.location)

    # List of tuples containing each explored waypoint, the current distance to that waypoint,
    # and the index of their previous waypoint along the path
    explored_list: List[Tuple[carla.Waypoint, int]] = []

    # List of Tuples used as a Priority Queue. The first int is the straight line distance
    # between the waypoint and the destination. The second Tuple contains the waypoint
    # and the index of the previous waypoint in the path
    potential_list: List[Tuple[int, Tuple[carla.Waypoint, int]]] = []

    # Add the initial point to the potential_list
    heapq.heappush(potential_list, (0, (starting_point, -1)))

    # Main A* loop
    while True:

        # Grab the current waypoint and previous index
        _, (current_waypoint, current_previous_index) = heapq.heappop(potential_list)

        # Add them to the explored list
        explored_list.append((current_waypoint, current_previous_index))

        # If the search is over, backtrack to build the path
        if Controller._end_of_search(current_waypoint, ending_point):
            waypoints = Controller._backtrack_path(explored_list)
            current_vehicle.waypoints = waypoints
            current_vehicle.trajectory = smooth_path(waypoints)
            return

        # Check all the potential next waypoints and add them to the potential list
        # if they haven&#39;t already been explored
        potential_new_waypoints = Controller._get_next_waypoints(current_waypoint)
        already_explored_waypoint_ids = [x[0].id for x in explored_list]
        for potential_new_waypoint in potential_new_waypoints:
            if potential_new_waypoint.id not in already_explored_waypoint_ids:
                distance_to_destination = np.linalg.norm(to_numpy_vector(potential_new_waypoint.transform.location)
                                                         - destination)
                heapq.heappush(potential_list,
                               (distance_to_destination + random.random(),
                                (potential_new_waypoint, len(explored_list) - 1)))

        # Handle the case of no path between the starting and ending waypoint
        if len(potential_list) == 0:
            raise Exception(f&#34;Unable to find path between waypoints {starting_point.id} and {ending_point.id}&#34;)</code></pre>
</details>
</dd>
<dt id="new_backend.Controller.Controller.steering_control"><code class="name flex">
<span>def <span class="ident">steering_control</span></span>(<span>current_vehicle: Vehicle.Vehicle) ‑> Tuple[float, bool]</span>
</code></dt>
<dd>
<div class="desc"><p>Implements path following using the Pure Pursuit Path Tracking algorithm.</p>
<p>Link to a paper on the subject can be found here:
<a href="https://www.ri.cmu.edu/publications/implementation-of-the-pure-pursuit-path-tracking-algorithm/">https://www.ri.cmu.edu/publications/implementation-of-the-pure-pursuit-path-tracking-algorithm/</a>
Determines what steering angle the vehicle needs to remain on the path outlined by its waypoints.
Chooses a lookahead distance based on the vehicle's current speed and identifies the waypoint
that is closest to that lookahead distance. Then, calculates the curve that connects the Vehicle's
current location to that destination waypoint. The inverse tangent of the curve can then be
taken to determine the steering angle needed.</p>
<p>:param current_vehicle: a Vehicle object representing the vehicle to be controlled
:return: a Tuple where the first element is a float representing the steering angle in radians
(bounded between -1 and 1) and the second element is if the Vehicle has reached
the end of the path</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def steering_control(current_vehicle: Vehicle) -&gt; Tuple[float, bool]:
    &#34;&#34;&#34;
    Implements path following using the Pure Pursuit Path Tracking algorithm.

    Link to a paper on the subject can be found here:
    https://www.ri.cmu.edu/publications/implementation-of-the-pure-pursuit-path-tracking-algorithm/
    Determines what steering angle the vehicle needs to remain on the path outlined by its waypoints.
    Chooses a lookahead distance based on the vehicle&#39;s current speed and identifies the waypoint
    that is closest to that lookahead distance. Then, calculates the curve that connects the Vehicle&#39;s
    current location to that destination waypoint. The inverse tangent of the curve can then be
    taken to determine the steering angle needed.

    :param current_vehicle: a Vehicle object representing the vehicle to be controlled
    :return: a Tuple where the first element is a float representing the steering angle in radians
             (bounded between -1 and 1) and the second element is if the Vehicle has reached
             the end of the path
    &#34;&#34;&#34;

    # Get the current location and forward facing vector of the vehicle
    current_location: np.array = current_vehicle.get_location_vector(dims=2)
    forward_facing_vector: np.array = to_numpy_vector(
        current_vehicle.carla_vehicle.get_transform().get_forward_vector(), dims=2)
    unit_forward_facing_vector: np.array = forward_facing_vector / np.linalg.norm(forward_facing_vector)

    # Find the closest waypoint to the vehicles current location
    trajectory: List[carla.Transform] = current_vehicle.trajectory
    trajectory_point_distances: List[np.array] = [
        np.linalg.norm(to_numpy_vector(x.location, dims=2) - current_location)
        for x in trajectory]
    nearest_trajectory_point_index = np.argmin(trajectory_point_distances)

    # Determine what our lookahead distance should be
    current_forward_speed = np.linalg.norm(to_numpy_vector(current_vehicle.carla_vehicle.get_velocity()))
    lookahead_distance = 4 + current_forward_speed * SPEED_CONSTANT

    # Find the next waypoint that is at least lookahead distance away, or at the end of the path
    current_distance = 0
    index = nearest_trajectory_point_index + 1
    while current_distance &lt; lookahead_distance and index &lt; len(trajectory):
        current_distance += np.linalg.norm(
            to_numpy_vector(trajectory[index].location) - to_numpy_vector(trajectory[index - 1].location))
        index += 1

    # Stop the car if we&#39;ve reached the end of the path
    if index &gt;= len(trajectory):
        return 0.0, True

    # Identify our new goal waypoint
    goal_trajectory_point = trajectory[index]
    distance_from_current_location_to_goal = trajectory_point_distances[index]

    # Calculate the angle between the vehicles forward facing vector and the distance vector between the
    # car and goal waypoint
    distance_vector = to_numpy_vector(goal_trajectory_point.location, dims=2) - current_location
    unit_distance_vector = distance_vector / np.linalg.norm(distance_vector)
    theta = np.arctan2(unit_distance_vector[1], unit_distance_vector[0]) - \
        np.arctan2(unit_forward_facing_vector[1], unit_forward_facing_vector[0])

    # Lastly, get the length of the vehicle and calculate the steering angle
    vehicle_length = current_vehicle.carla_vehicle.bounding_box.extent.y * 2
    steering_angle = np.arctan2(2 * vehicle_length * np.sin(theta), distance_from_current_location_to_goal)

    return steering_angle, False</code></pre>
</details>
</dd>
<dt id="new_backend.Controller.Controller.throttle_control"><code class="name flex">
<span>def <span class="ident">throttle_control</span></span>(<span>current_vehicle: Vehicle.Vehicle) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Applies throttle control to the vehicle based on its current setting.</p>
<p>The different modes that a vehicle can operate in are a "target_location", "target_speed", or
"target_distance".</p>
<p>In target_location mode, the vehicle will accelerate maintain its target speed
until it is within a certain distance of its target location. Then, it will brake to smoothly
stop at that location. This mode is activated if the current_vehicle has a valid target location
and the vehicle is within its pre-defined breaking distance.</p>
<p>In target_distance mode, the vehicle will accelerate or decelerate as necessary to maintain a
target distance from the vehicle in-front of it. This mode is activated if there is a vehicle in front
of the current vehicle within 1.2 times the current vehicle's safety distance. This mode can never be
activated for a lead vehicle.</p>
<p>In target_speed mode, the vehicle will accelerate up to its target speed and then apply the acceleration
necessary to maintain that speed. This mode will be activated if neither of the other modes apply.</p>
<p>:param current_vehicle: the Vehicle object to calculate the throttle for
:return: a float representing the throttle to be applied to the vehicle (between -1 and 1)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def throttle_control(current_vehicle: Vehicle) -&gt; float:
    &#34;&#34;&#34;
    Applies throttle control to the vehicle based on its current setting.

    The different modes that a vehicle can operate in are a &#34;target_location&#34;, &#34;target_speed&#34;, or
    &#34;target_distance&#34;.

    In target_location mode, the vehicle will accelerate maintain its target speed
    until it is within a certain distance of its target location. Then, it will brake to smoothly
    stop at that location. This mode is activated if the current_vehicle has a valid target location
    and the vehicle is within its pre-defined breaking distance.

    In target_distance mode, the vehicle will accelerate or decelerate as necessary to maintain a
    target distance from the vehicle in-front of it. This mode is activated if there is a vehicle in front
    of the current vehicle within 1.2 times the current vehicle&#39;s safety distance. This mode can never be
    activated for a lead vehicle.

    In target_speed mode, the vehicle will accelerate up to its target speed and then apply the acceleration
    necessary to maintain that speed. This mode will be activated if neither of the other modes apply.

    :param current_vehicle: the Vehicle object to calculate the throttle for
    :return: a float representing the throttle to be applied to the vehicle (between -1 and 1)
    &#34;&#34;&#34;

    # Apply the target location control if necessary
    if current_vehicle.target_location is not None:
        current_distance = np.sum(to_numpy_vector(current_vehicle.target_location) -
                                  current_vehicle.get_location_vector())
        if current_distance &lt;= current_vehicle.breaking_distance:
            return Controller._throttle_target_location(current_vehicle)

    # Apply the target distance control if necessary
    if current_vehicle.type_id != VehicleType.LEAD:
        car_in_front, current_distance = current_vehicle.check_vehicle_in_front()
        if car_in_front:
            return Controller._throttle_target_distance(current_vehicle, current_distance)

    # Lastly, apply target speed control
    return Controller._throttle_target_speed(current_vehicle)</code></pre>
</details>
</dd>
<dt id="new_backend.Controller.Controller.update_control"><code class="name flex">
<span>def <span class="ident">update_control</span></span>(<span>current_vehicle: Vehicle.Vehicle) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Abstract function that dictates how a derived Controller class should update the Vehicles control.</p>
<p>All derived controller classes must implement this method. The update_control method takes in a
vehicle and determines what control parameters should be passed to it to update its acceleration
and steering in the Carla simulation. This function will call apply_control on the current
vehicle to steer the vehicle in the correct direction.</p>
<p>:param current_vehicle: the Vehicle object to which updated control needs to be applied
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def update_control(current_vehicle: Vehicle) -&gt; None:
    &#34;&#34;&#34;
    Abstract function that dictates how a derived Controller class should update the Vehicles control.

    All derived controller classes must implement this method. The update_control method takes in a
    vehicle and determines what control parameters should be passed to it to update its acceleration
    and steering in the Carla simulation. This function will call apply_control on the current
    vehicle to steer the vehicle in the correct direction.

    :param current_vehicle: the Vehicle object to which updated control needs to be applied
    :return: None
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="new_backend" href="index.html">new_backend</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="new_backend.Controller.Controller" href="#new_backend.Controller.Controller">Controller</a></code></h4>
<ul class="">
<li><code><a title="new_backend.Controller.Controller.generate_path" href="#new_backend.Controller.Controller.generate_path">generate_path</a></code></li>
<li><code><a title="new_backend.Controller.Controller.steering_control" href="#new_backend.Controller.Controller.steering_control">steering_control</a></code></li>
<li><code><a title="new_backend.Controller.Controller.throttle_control" href="#new_backend.Controller.Controller.throttle_control">throttle_control</a></code></li>
<li><code><a title="new_backend.Controller.Controller.update_control" href="#new_backend.Controller.Controller.update_control">update_control</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>