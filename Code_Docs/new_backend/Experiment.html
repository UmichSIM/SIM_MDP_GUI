<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>new_backend.Experiment API documentation</title>
<meta name="description" content="Backend - Experiment Class
Created on Tue February 15, 2022 â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>new_backend.Experiment</code></h1>
</header>
<section id="section-intro">
<p>Backend - Experiment Class
Created on Tue February 15, 2022</p>
<p>Summary: The Experiment class is a base class that describes the high level interface that all
derived experiments must implement. It provides all the functionality that is universal to all
experiments and experiment types. Specific experiment types and specific maps must be represented
as derived classes from this base class.</p>
<h2 id="references">References</h2>
<p>CarlaModules
EgoController
FreewayController
Helpers
IntersectionController
Section
Threading
Vehicle</p>
<p>Referenced By:
MapExplorationExperiment
TestExperiment</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Backend - Experiment Class
Created on Tue February 15, 2022

Summary: The Experiment class is a base class that describes the high level interface that all
    derived experiments must implement. It provides all the functionality that is universal to all
    experiments and experiment types. Specific experiment types and specific maps must be represented
    as derived classes from this base class.

References:
    CarlaModules
    EgoController
    FreewayController
    Helpers
    IntersectionController
    Section
    Threading
    Vehicle

Referenced By:
    MapExplorationExperiment
    TestExperiment

&#34;&#34;&#34;

# Local Imports
from CarlaModules.HUD import HUD
from CarlaModules.World import World
from CarlaModules.KeyboardController import KeyboardControl
from CarlaModules.GlobalFunctions import DefaultSettings
from EgoController import EgoController
from FreewayController import FreewayController
from Helpers import ExperimentType, VehicleType
from IntersectionController import IntersectionController
from Section import Section
from Threading import SIMThread, ThreadWorker
from Vehicle import Vehicle

# Library Imports
import carla
import logging
import pygame
import random
import sys
from typing import List, Dict


# noinspection PyTypeChecker
class Experiment:

    # Static variable denoting which map this experiment takes place on
    # Can be overridden by derived classes
    MAP = &#34;Town05&#34;

    # The Type of Experiment that is currently running
    experiment_type: ExperimentType = None

    def __init__(self, headless: bool):

        # Indicates whether the experiment is being run with a GUI or standalone
        self.headless = headless

        # A Carla.Client object that stores the current connection to the server
        self.client: carla.Client = None

        # A Carla.World object that stores the current world the simulation is running in
        self.world: carla.World = None

        # A Carla.Action that represents the spectator in the Simulation
        self.spectator: carla.Actor = None

        # A single SIMThread to handle all threaded execution
        self.sim_thread: SIMThread = None

        # Track whether the connection to the server has been initialized
        self.server_initialized = False

        # Store the specific vehicle that is the Ego vehicle
        self.ego_vehicle: Vehicle = None

        # List of all vehicles in the Simulation
        self.vehicle_list: List[Vehicle] = []

        # List of all Sections (Intersections / Freeway Sections) in the Simulation
        self.section_list: List[Section] = []

    def initialize_carla_server(self, blocking: bool = False, port: int = 2000) -&gt; None:
        &#34;&#34;&#34;
        Connects to the Carla server.

        :param blocking: a bool representing whether connecting to the server should block the GUI
                         or allow it to continue
        :param port: an int specifying the network port to connect to (defaults to 2000)
        :returns: None
        &#34;&#34;&#34;

        # If blocking, just directly call the connection functions
        if blocking:
            try:
                self._initialize_server_private(port)
                self._finish_server_connection(True)
            except Exception as e:
                logging.error(e)
                self._finish_server_connection(False)
            return

        # If non-blocking, call the connection functions in a separate thread
        worker = ThreadWorker(self._initialize_server_private, port)
        worker.call_when_finished(self._finish_server_connection)
        self.sim_thread = SIMThread(worker, &#34;single&#34;)

    def _initialize_server_private(self, port: int = 2000) -&gt; None:
        &#34;&#34;&#34;
        Private function that handles the bulk of connecting to the Carla server.

        Separate private function is necessary to take advantage of QThreads. Designed to be run on
        a worker thread (non-main thread)

        :param port: an int specifying the network port to connect to (defaults to 2000)
        :return: None
        &#34;&#34;&#34;

        logging.info(f&#34;Connecting to the Server on port {port}&#34;)

        # Connect to the Carla server
        self.client = carla.Client(&#34;localhost&#34;, port)
        self.client.set_timeout(20.0)
        self.world = self.client.load_world(self.MAP)

        # Set the world to have some default weather parameters
        weather = carla.WeatherParameters(
            cloudiness=10.0,
            precipitation=0.0,
            sun_altitude_angle=90.0)
        self.world.set_weather(weather)

        # Set the world spectator to some arbitrary position
        self.spectator = self.world.get_spectator()
        self.spectator.set_transform(
            carla.Transform(carla.Location(x=-170, y=-151, z=116.5), carla.Rotation(pitch=-33, yaw=56.9, roll=0.0)))

    def _finish_server_connection(self, status: bool) -&gt; None:
        &#34;&#34;&#34;
        Private function that handles updating the GUI after the connection to the Carla server is made.

        Should be connected to the worker thread&#39;s &#34;Finished&#34; signal. Must be run on the main thread
        in order to update the GUI. On successful connection, will display a toast style notification
        indicating that the connection succeeded. On failure, will display an error message and close
        the GUI. If the experiment is currently headless, only command line output will be created.

        :param status: a bool indicating if connection to the Carla server was successful
        :return: None
        &#34;&#34;&#34;

        if status:
            self.server_initialized = True
            # TODO: display some message in the GUI when connected to the server
            logging.info(f&#34;Successfully connected to the Carla Server&#34;)
            return

        # Exit the GUI if unable to connect to server
        logging.error(&#34;Unable to connect to Carla Server&#34;)
        sys.exit(-1)

    def initialize_experiment(self, configuration: Dict[str, str]) -&gt; None:
        &#34;&#34;&#34;
        Uses an existing connection to the Carla server and configures the world according to the experiment design.

        THIS FUNCTION IS ABSTRACT, IT MUST BE IMPLEMENTED BY THE DERIVED EXPERIMENT CLASS. OTHERWISE,
        NOTHING WILL HAPPEN WHEN YOU GO TO RUN THE EXPERIMENT.
        Adds vehicles in the places specified in the GUI, generates paths for all non-Ego vehicles,
        specifies traffic light settings.

        :param configuration: a Dictionary containing the user defined settings for the experiment (exact properties
                              vary from experiment to experiment)
        :return: None
        &#34;&#34;&#34;
        pass

    def run_experiment(self) -&gt; None:
        &#34;&#34;&#34;
        Runs a basic main simulation loop to drive the experiment.

        Any additional functionality can be added by overloading this function in a derived class.
        Spawns a new thread to control each manually driven vehicle. Each tick, updates the positions of
        each vehicle and applies autonomous control to each vehicle.

        :return: None
        &#34;&#34;&#34;

        # Initialize Pygame to handle user input
        pygame.init()

        # Initialize the Pygame display
        display = pygame.display.set_mode(
            (0, 0),
            pygame.HWSURFACE | pygame.DOUBLEBUF | pygame.FULLSCREEN)
        display.fill((0, 0, 0))
        pygame.display.flip()

        # Initialize the objects that will be rendered by Pygame
        hud = HUD(display.get_size()[0], display.get_size()[1])
        world = World(self.ego_vehicle.carla_vehicle, self.world, hud, DefaultSettings())

        # Initialize the controller to handle user input
        controller = KeyboardControl(world, False)

        try:
            # Loop continuously
            clock = pygame.time.Clock()
            while True:

                # Tick the Carla Simulation
                self.world.tick()
                clock.tick(60)
                pygame.event.pump()

                # Update the relative locations of each vehicle
                for vehicle in self.vehicle_list + [self.ego_vehicle]:
                    vehicle.update_other_vehicle_locations(self.vehicle_list)

                # Apply control to the Ego Vehicle
                if self.ego_vehicle is not None:
                    # Lambda used to avoid passing all the arguments into the update_control function
                    EgoController.update_control(self.ego_vehicle,
                                                 lambda: controller.parse_events(self.client, world, clock, True),
                                                 self.experiment_type)

                # Apply control to every other Vehicle
                for vehicle in self.vehicle_list:
                    if self.experiment_type == ExperimentType.INTERSECTION:
                        IntersectionController.update_control(vehicle)
                    elif self.experiment_type == ExperimentType.FREEWAY:
                        FreewayController.update_control(vehicle)

                # Update the UI elements
                world.tick(clock, self.ego_vehicle)
                world.render(display)
                pygame.display.flip()

        finally:
            world.destroy()

    def clean_up_experiment(self) -&gt; None:
        &#34;&#34;&#34;
        Destroys all the actors that have been spawned in the Carla simulation.

        :return: None
        &#34;&#34;&#34;
        for vehicle in self.vehicle_list:
            vehicle.carla_vehicle.destroy()

    # TODO: add new parameters to this function as needed
    def add_vehicle(self, spawn_location: carla.Transform, type_id: VehicleType, ego: bool = False,
                    blueprint_id: str = None) -&gt; Vehicle:
        &#34;&#34;&#34;
        Adds a new Vehicle to the experiment.

        The new vehicle will be added at the location specified by spawn_location. The specific type of the vehicle
        must be specified so the correct type of control is applied to the vehicle.

        :param spawn_location: a carla.Transform representing where the Vehicle should spawn in the world
        :param type_id: the VehicleType of the carla.Vehicle to specify the type of the Vehicle
        :param ego: a bool representing whether the new Vehicle is the Ego Vehicle or not
        :param blueprint_id: a str representing the specific name of the Vehicle blueprint to use. If not provided,
                          a random blueprint is used
        :returns: the created Vehicle object
        &#34;&#34;&#34;

        # Grab the selected blueprint if one was provided, otherwise select a random non-bike blueprint
        blueprint_list = self.world.get_blueprint_library().filter(&#39;vehicle.*.*&#39;)
        if blueprint_id is not None:
            blueprint = blueprint_list.find(blueprint_id)
        else:
            blueprint_list = [x for x in blueprint_list if int(x.get_attribute(&#39;number_of_wheels&#39;)) != 2]
            blueprint = random.choice(blueprint_list)

        if ego:
            if self.ego_vehicle is not None:
                raise Exception(&#34;Unable to add multiple ego vehicles.&#34;)

            # Create a new ego vehicle in the Simulation
            new_carla_vehicle = self.world.spawn_actor(blueprint, spawn_location)
            new_vehicle = Vehicle(new_carla_vehicle, &#34;Ego&#34;, type_id)
            self.ego_vehicle = new_vehicle

            # Set the camera to be located at the Ego vehicle
            self.world.tick()
            self.spectator.set_transform(new_vehicle.carla_vehicle.get_transform())

        else:
            # Create a new non-ego vehicle in the Simulation
            new_carla_vehicle = self.world.spawn_actor(blueprint, spawn_location)
            new_vehicle = Vehicle(new_carla_vehicle, &#34;temp_id&#34;, VehicleType.GENERIC)
            self.vehicle_list.append(new_vehicle)

        return new_vehicle</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="new_backend.Experiment.Experiment"><code class="flex name class">
<span>class <span class="ident">Experiment</span></span>
<span>(</span><span>headless:Â bool)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Experiment:

    # Static variable denoting which map this experiment takes place on
    # Can be overridden by derived classes
    MAP = &#34;Town05&#34;

    # The Type of Experiment that is currently running
    experiment_type: ExperimentType = None

    def __init__(self, headless: bool):

        # Indicates whether the experiment is being run with a GUI or standalone
        self.headless = headless

        # A Carla.Client object that stores the current connection to the server
        self.client: carla.Client = None

        # A Carla.World object that stores the current world the simulation is running in
        self.world: carla.World = None

        # A Carla.Action that represents the spectator in the Simulation
        self.spectator: carla.Actor = None

        # A single SIMThread to handle all threaded execution
        self.sim_thread: SIMThread = None

        # Track whether the connection to the server has been initialized
        self.server_initialized = False

        # Store the specific vehicle that is the Ego vehicle
        self.ego_vehicle: Vehicle = None

        # List of all vehicles in the Simulation
        self.vehicle_list: List[Vehicle] = []

        # List of all Sections (Intersections / Freeway Sections) in the Simulation
        self.section_list: List[Section] = []

    def initialize_carla_server(self, blocking: bool = False, port: int = 2000) -&gt; None:
        &#34;&#34;&#34;
        Connects to the Carla server.

        :param blocking: a bool representing whether connecting to the server should block the GUI
                         or allow it to continue
        :param port: an int specifying the network port to connect to (defaults to 2000)
        :returns: None
        &#34;&#34;&#34;

        # If blocking, just directly call the connection functions
        if blocking:
            try:
                self._initialize_server_private(port)
                self._finish_server_connection(True)
            except Exception as e:
                logging.error(e)
                self._finish_server_connection(False)
            return

        # If non-blocking, call the connection functions in a separate thread
        worker = ThreadWorker(self._initialize_server_private, port)
        worker.call_when_finished(self._finish_server_connection)
        self.sim_thread = SIMThread(worker, &#34;single&#34;)

    def _initialize_server_private(self, port: int = 2000) -&gt; None:
        &#34;&#34;&#34;
        Private function that handles the bulk of connecting to the Carla server.

        Separate private function is necessary to take advantage of QThreads. Designed to be run on
        a worker thread (non-main thread)

        :param port: an int specifying the network port to connect to (defaults to 2000)
        :return: None
        &#34;&#34;&#34;

        logging.info(f&#34;Connecting to the Server on port {port}&#34;)

        # Connect to the Carla server
        self.client = carla.Client(&#34;localhost&#34;, port)
        self.client.set_timeout(20.0)
        self.world = self.client.load_world(self.MAP)

        # Set the world to have some default weather parameters
        weather = carla.WeatherParameters(
            cloudiness=10.0,
            precipitation=0.0,
            sun_altitude_angle=90.0)
        self.world.set_weather(weather)

        # Set the world spectator to some arbitrary position
        self.spectator = self.world.get_spectator()
        self.spectator.set_transform(
            carla.Transform(carla.Location(x=-170, y=-151, z=116.5), carla.Rotation(pitch=-33, yaw=56.9, roll=0.0)))

    def _finish_server_connection(self, status: bool) -&gt; None:
        &#34;&#34;&#34;
        Private function that handles updating the GUI after the connection to the Carla server is made.

        Should be connected to the worker thread&#39;s &#34;Finished&#34; signal. Must be run on the main thread
        in order to update the GUI. On successful connection, will display a toast style notification
        indicating that the connection succeeded. On failure, will display an error message and close
        the GUI. If the experiment is currently headless, only command line output will be created.

        :param status: a bool indicating if connection to the Carla server was successful
        :return: None
        &#34;&#34;&#34;

        if status:
            self.server_initialized = True
            # TODO: display some message in the GUI when connected to the server
            logging.info(f&#34;Successfully connected to the Carla Server&#34;)
            return

        # Exit the GUI if unable to connect to server
        logging.error(&#34;Unable to connect to Carla Server&#34;)
        sys.exit(-1)

    def initialize_experiment(self, configuration: Dict[str, str]) -&gt; None:
        &#34;&#34;&#34;
        Uses an existing connection to the Carla server and configures the world according to the experiment design.

        THIS FUNCTION IS ABSTRACT, IT MUST BE IMPLEMENTED BY THE DERIVED EXPERIMENT CLASS. OTHERWISE,
        NOTHING WILL HAPPEN WHEN YOU GO TO RUN THE EXPERIMENT.
        Adds vehicles in the places specified in the GUI, generates paths for all non-Ego vehicles,
        specifies traffic light settings.

        :param configuration: a Dictionary containing the user defined settings for the experiment (exact properties
                              vary from experiment to experiment)
        :return: None
        &#34;&#34;&#34;
        pass

    def run_experiment(self) -&gt; None:
        &#34;&#34;&#34;
        Runs a basic main simulation loop to drive the experiment.

        Any additional functionality can be added by overloading this function in a derived class.
        Spawns a new thread to control each manually driven vehicle. Each tick, updates the positions of
        each vehicle and applies autonomous control to each vehicle.

        :return: None
        &#34;&#34;&#34;

        # Initialize Pygame to handle user input
        pygame.init()

        # Initialize the Pygame display
        display = pygame.display.set_mode(
            (0, 0),
            pygame.HWSURFACE | pygame.DOUBLEBUF | pygame.FULLSCREEN)
        display.fill((0, 0, 0))
        pygame.display.flip()

        # Initialize the objects that will be rendered by Pygame
        hud = HUD(display.get_size()[0], display.get_size()[1])
        world = World(self.ego_vehicle.carla_vehicle, self.world, hud, DefaultSettings())

        # Initialize the controller to handle user input
        controller = KeyboardControl(world, False)

        try:
            # Loop continuously
            clock = pygame.time.Clock()
            while True:

                # Tick the Carla Simulation
                self.world.tick()
                clock.tick(60)
                pygame.event.pump()

                # Update the relative locations of each vehicle
                for vehicle in self.vehicle_list + [self.ego_vehicle]:
                    vehicle.update_other_vehicle_locations(self.vehicle_list)

                # Apply control to the Ego Vehicle
                if self.ego_vehicle is not None:
                    # Lambda used to avoid passing all the arguments into the update_control function
                    EgoController.update_control(self.ego_vehicle,
                                                 lambda: controller.parse_events(self.client, world, clock, True),
                                                 self.experiment_type)

                # Apply control to every other Vehicle
                for vehicle in self.vehicle_list:
                    if self.experiment_type == ExperimentType.INTERSECTION:
                        IntersectionController.update_control(vehicle)
                    elif self.experiment_type == ExperimentType.FREEWAY:
                        FreewayController.update_control(vehicle)

                # Update the UI elements
                world.tick(clock, self.ego_vehicle)
                world.render(display)
                pygame.display.flip()

        finally:
            world.destroy()

    def clean_up_experiment(self) -&gt; None:
        &#34;&#34;&#34;
        Destroys all the actors that have been spawned in the Carla simulation.

        :return: None
        &#34;&#34;&#34;
        for vehicle in self.vehicle_list:
            vehicle.carla_vehicle.destroy()

    # TODO: add new parameters to this function as needed
    def add_vehicle(self, spawn_location: carla.Transform, type_id: VehicleType, ego: bool = False,
                    blueprint_id: str = None) -&gt; Vehicle:
        &#34;&#34;&#34;
        Adds a new Vehicle to the experiment.

        The new vehicle will be added at the location specified by spawn_location. The specific type of the vehicle
        must be specified so the correct type of control is applied to the vehicle.

        :param spawn_location: a carla.Transform representing where the Vehicle should spawn in the world
        :param type_id: the VehicleType of the carla.Vehicle to specify the type of the Vehicle
        :param ego: a bool representing whether the new Vehicle is the Ego Vehicle or not
        :param blueprint_id: a str representing the specific name of the Vehicle blueprint to use. If not provided,
                          a random blueprint is used
        :returns: the created Vehicle object
        &#34;&#34;&#34;

        # Grab the selected blueprint if one was provided, otherwise select a random non-bike blueprint
        blueprint_list = self.world.get_blueprint_library().filter(&#39;vehicle.*.*&#39;)
        if blueprint_id is not None:
            blueprint = blueprint_list.find(blueprint_id)
        else:
            blueprint_list = [x for x in blueprint_list if int(x.get_attribute(&#39;number_of_wheels&#39;)) != 2]
            blueprint = random.choice(blueprint_list)

        if ego:
            if self.ego_vehicle is not None:
                raise Exception(&#34;Unable to add multiple ego vehicles.&#34;)

            # Create a new ego vehicle in the Simulation
            new_carla_vehicle = self.world.spawn_actor(blueprint, spawn_location)
            new_vehicle = Vehicle(new_carla_vehicle, &#34;Ego&#34;, type_id)
            self.ego_vehicle = new_vehicle

            # Set the camera to be located at the Ego vehicle
            self.world.tick()
            self.spectator.set_transform(new_vehicle.carla_vehicle.get_transform())

        else:
            # Create a new non-ego vehicle in the Simulation
            new_carla_vehicle = self.world.spawn_actor(blueprint, spawn_location)
            new_vehicle = Vehicle(new_carla_vehicle, &#34;temp_id&#34;, VehicleType.GENERIC)
            self.vehicle_list.append(new_vehicle)

        return new_vehicle</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="new_backend.Experiment.Experiment.MAP"><code class="name">var <span class="ident">MAP</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="new_backend.Experiment.Experiment.experiment_type"><code class="name">var <span class="ident">experiment_type</span> :Â Helpers.ExperimentType</code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="new_backend.Experiment.Experiment.add_vehicle"><code class="name flex">
<span>def <span class="ident">add_vehicle</span></span>(<span>self, spawn_location:Â carla.libcarla.Transform, type_id:Â Helpers.VehicleType, ego:Â boolÂ =Â False, blueprint_id:Â strÂ =Â None) â€‘>Â Vehicle.Vehicle</span>
</code></dt>
<dd>
<div class="desc"><p>Adds a new Vehicle to the experiment.</p>
<p>The new vehicle will be added at the location specified by spawn_location. The specific type of the vehicle
must be specified so the correct type of control is applied to the vehicle.</p>
<p>:param spawn_location: a carla.Transform representing where the Vehicle should spawn in the world
:param type_id: the VehicleType of the carla.Vehicle to specify the type of the Vehicle
:param ego: a bool representing whether the new Vehicle is the Ego Vehicle or not
:param blueprint_id: a str representing the specific name of the Vehicle blueprint to use. If not provided,
a random blueprint is used
:returns: the created Vehicle object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_vehicle(self, spawn_location: carla.Transform, type_id: VehicleType, ego: bool = False,
                blueprint_id: str = None) -&gt; Vehicle:
    &#34;&#34;&#34;
    Adds a new Vehicle to the experiment.

    The new vehicle will be added at the location specified by spawn_location. The specific type of the vehicle
    must be specified so the correct type of control is applied to the vehicle.

    :param spawn_location: a carla.Transform representing where the Vehicle should spawn in the world
    :param type_id: the VehicleType of the carla.Vehicle to specify the type of the Vehicle
    :param ego: a bool representing whether the new Vehicle is the Ego Vehicle or not
    :param blueprint_id: a str representing the specific name of the Vehicle blueprint to use. If not provided,
                      a random blueprint is used
    :returns: the created Vehicle object
    &#34;&#34;&#34;

    # Grab the selected blueprint if one was provided, otherwise select a random non-bike blueprint
    blueprint_list = self.world.get_blueprint_library().filter(&#39;vehicle.*.*&#39;)
    if blueprint_id is not None:
        blueprint = blueprint_list.find(blueprint_id)
    else:
        blueprint_list = [x for x in blueprint_list if int(x.get_attribute(&#39;number_of_wheels&#39;)) != 2]
        blueprint = random.choice(blueprint_list)

    if ego:
        if self.ego_vehicle is not None:
            raise Exception(&#34;Unable to add multiple ego vehicles.&#34;)

        # Create a new ego vehicle in the Simulation
        new_carla_vehicle = self.world.spawn_actor(blueprint, spawn_location)
        new_vehicle = Vehicle(new_carla_vehicle, &#34;Ego&#34;, type_id)
        self.ego_vehicle = new_vehicle

        # Set the camera to be located at the Ego vehicle
        self.world.tick()
        self.spectator.set_transform(new_vehicle.carla_vehicle.get_transform())

    else:
        # Create a new non-ego vehicle in the Simulation
        new_carla_vehicle = self.world.spawn_actor(blueprint, spawn_location)
        new_vehicle = Vehicle(new_carla_vehicle, &#34;temp_id&#34;, VehicleType.GENERIC)
        self.vehicle_list.append(new_vehicle)

    return new_vehicle</code></pre>
</details>
</dd>
<dt id="new_backend.Experiment.Experiment.clean_up_experiment"><code class="name flex">
<span>def <span class="ident">clean_up_experiment</span></span>(<span>self) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Destroys all the actors that have been spawned in the Carla simulation.</p>
<p>:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clean_up_experiment(self) -&gt; None:
    &#34;&#34;&#34;
    Destroys all the actors that have been spawned in the Carla simulation.

    :return: None
    &#34;&#34;&#34;
    for vehicle in self.vehicle_list:
        vehicle.carla_vehicle.destroy()</code></pre>
</details>
</dd>
<dt id="new_backend.Experiment.Experiment.initialize_carla_server"><code class="name flex">
<span>def <span class="ident">initialize_carla_server</span></span>(<span>self, blocking:Â boolÂ =Â False, port:Â intÂ =Â 2000) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Connects to the Carla server.</p>
<p>:param blocking: a bool representing whether connecting to the server should block the GUI
or allow it to continue
:param port: an int specifying the network port to connect to (defaults to 2000)
:returns: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initialize_carla_server(self, blocking: bool = False, port: int = 2000) -&gt; None:
    &#34;&#34;&#34;
    Connects to the Carla server.

    :param blocking: a bool representing whether connecting to the server should block the GUI
                     or allow it to continue
    :param port: an int specifying the network port to connect to (defaults to 2000)
    :returns: None
    &#34;&#34;&#34;

    # If blocking, just directly call the connection functions
    if blocking:
        try:
            self._initialize_server_private(port)
            self._finish_server_connection(True)
        except Exception as e:
            logging.error(e)
            self._finish_server_connection(False)
        return

    # If non-blocking, call the connection functions in a separate thread
    worker = ThreadWorker(self._initialize_server_private, port)
    worker.call_when_finished(self._finish_server_connection)
    self.sim_thread = SIMThread(worker, &#34;single&#34;)</code></pre>
</details>
</dd>
<dt id="new_backend.Experiment.Experiment.initialize_experiment"><code class="name flex">
<span>def <span class="ident">initialize_experiment</span></span>(<span>self, configuration:Â Dict[str,Â str]) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Uses an existing connection to the Carla server and configures the world according to the experiment design.</p>
<p>THIS FUNCTION IS ABSTRACT, IT MUST BE IMPLEMENTED BY THE DERIVED EXPERIMENT CLASS. OTHERWISE,
NOTHING WILL HAPPEN WHEN YOU GO TO RUN THE EXPERIMENT.
Adds vehicles in the places specified in the GUI, generates paths for all non-Ego vehicles,
specifies traffic light settings.</p>
<p>:param configuration: a Dictionary containing the user defined settings for the experiment (exact properties
vary from experiment to experiment)
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def initialize_experiment(self, configuration: Dict[str, str]) -&gt; None:
    &#34;&#34;&#34;
    Uses an existing connection to the Carla server and configures the world according to the experiment design.

    THIS FUNCTION IS ABSTRACT, IT MUST BE IMPLEMENTED BY THE DERIVED EXPERIMENT CLASS. OTHERWISE,
    NOTHING WILL HAPPEN WHEN YOU GO TO RUN THE EXPERIMENT.
    Adds vehicles in the places specified in the GUI, generates paths for all non-Ego vehicles,
    specifies traffic light settings.

    :param configuration: a Dictionary containing the user defined settings for the experiment (exact properties
                          vary from experiment to experiment)
    :return: None
    &#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="new_backend.Experiment.Experiment.run_experiment"><code class="name flex">
<span>def <span class="ident">run_experiment</span></span>(<span>self) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Runs a basic main simulation loop to drive the experiment.</p>
<p>Any additional functionality can be added by overloading this function in a derived class.
Spawns a new thread to control each manually driven vehicle. Each tick, updates the positions of
each vehicle and applies autonomous control to each vehicle.</p>
<p>:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_experiment(self) -&gt; None:
    &#34;&#34;&#34;
    Runs a basic main simulation loop to drive the experiment.

    Any additional functionality can be added by overloading this function in a derived class.
    Spawns a new thread to control each manually driven vehicle. Each tick, updates the positions of
    each vehicle and applies autonomous control to each vehicle.

    :return: None
    &#34;&#34;&#34;

    # Initialize Pygame to handle user input
    pygame.init()

    # Initialize the Pygame display
    display = pygame.display.set_mode(
        (0, 0),
        pygame.HWSURFACE | pygame.DOUBLEBUF | pygame.FULLSCREEN)
    display.fill((0, 0, 0))
    pygame.display.flip()

    # Initialize the objects that will be rendered by Pygame
    hud = HUD(display.get_size()[0], display.get_size()[1])
    world = World(self.ego_vehicle.carla_vehicle, self.world, hud, DefaultSettings())

    # Initialize the controller to handle user input
    controller = KeyboardControl(world, False)

    try:
        # Loop continuously
        clock = pygame.time.Clock()
        while True:

            # Tick the Carla Simulation
            self.world.tick()
            clock.tick(60)
            pygame.event.pump()

            # Update the relative locations of each vehicle
            for vehicle in self.vehicle_list + [self.ego_vehicle]:
                vehicle.update_other_vehicle_locations(self.vehicle_list)

            # Apply control to the Ego Vehicle
            if self.ego_vehicle is not None:
                # Lambda used to avoid passing all the arguments into the update_control function
                EgoController.update_control(self.ego_vehicle,
                                             lambda: controller.parse_events(self.client, world, clock, True),
                                             self.experiment_type)

            # Apply control to every other Vehicle
            for vehicle in self.vehicle_list:
                if self.experiment_type == ExperimentType.INTERSECTION:
                    IntersectionController.update_control(vehicle)
                elif self.experiment_type == ExperimentType.FREEWAY:
                    FreewayController.update_control(vehicle)

            # Update the UI elements
            world.tick(clock, self.ego_vehicle)
            world.render(display)
            pygame.display.flip()

    finally:
        world.destroy()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="new_backend" href="index.html">new_backend</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="new_backend.Experiment.Experiment" href="#new_backend.Experiment.Experiment">Experiment</a></code></h4>
<ul class="">
<li><code><a title="new_backend.Experiment.Experiment.MAP" href="#new_backend.Experiment.Experiment.MAP">MAP</a></code></li>
<li><code><a title="new_backend.Experiment.Experiment.add_vehicle" href="#new_backend.Experiment.Experiment.add_vehicle">add_vehicle</a></code></li>
<li><code><a title="new_backend.Experiment.Experiment.clean_up_experiment" href="#new_backend.Experiment.Experiment.clean_up_experiment">clean_up_experiment</a></code></li>
<li><code><a title="new_backend.Experiment.Experiment.experiment_type" href="#new_backend.Experiment.Experiment.experiment_type">experiment_type</a></code></li>
<li><code><a title="new_backend.Experiment.Experiment.initialize_carla_server" href="#new_backend.Experiment.Experiment.initialize_carla_server">initialize_carla_server</a></code></li>
<li><code><a title="new_backend.Experiment.Experiment.initialize_experiment" href="#new_backend.Experiment.Experiment.initialize_experiment">initialize_experiment</a></code></li>
<li><code><a title="new_backend.Experiment.Experiment.run_experiment" href="#new_backend.Experiment.Experiment.run_experiment">run_experiment</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>