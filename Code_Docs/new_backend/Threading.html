<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>new_backend.Threading API documentation</title>
<meta name="description" content="Backend - Threading Classes
Created on Mon February 28, 2022 â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>new_backend.Threading</code></h1>
</header>
<section id="section-intro">
<p>Backend - Threading Classes
Created on Mon February 28, 2022</p>
<p>Summary: The Threading classes provide a high level interface for running functions on a
separate thread of execution. The SIMThread class takes in a specific Worker type and function
and executes that function according to the rules of the given worker. A ThreadWorker will
execute the function once, and exposes a signal that can call a secondary function when the
initial function finishes. A SignaledWorker will execute the function whenever it is signaled.
This signal can be sent multiple times.</p>
<h2 id="references">References</h2>
<p>None</p>
<p>Referenced By:
Experiment
MapExplorationExperiment
TestExperiment</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Backend - Threading Classes
Created on Mon February 28, 2022

Summary: The Threading classes provide a high level interface for running functions on a
         separate thread of execution. The SIMThread class takes in a specific Worker type and function
         and executes that function according to the rules of the given worker. A ThreadWorker will
         execute the function once, and exposes a signal that can call a secondary function when the
         initial function finishes. A SignaledWorker will execute the function whenever it is signaled.
         This signal can be sent multiple times.

References:
    None

Referenced By:
    Experiment
    MapExplorationExperiment
    TestExperiment

&#34;&#34;&#34;

# Library Imports
import logging
from PyQt5.QtCore import QObject, QThread, pyqtSignal
from PyQt5.QtWidgets import QMainWindow
from typing import Callable


class ThreadWorker(QObject):

    # The signals that can be connected to slots on another thread
    finished: pyqtSignal = pyqtSignal(bool)

    def __init__(self, function: Callable, *args):
        # Call the base QObject constructor
        super(ThreadWorker, self).__init__()

        # This function is the one that the Thread will execute when run
        self.function: Callable = function

        # Store the args that need to be passed to the called function
        self.args = args

    def call_when_finished(self, function: Callable) -&gt; None:
        &#34;&#34;&#34;
        Allows the user to specify a second function that will be called when the thread finishes.

        The function pass in here will be triggered on the main thread whenever this worker has
        finished. For a ThreadWorker, this second function will run once the main function has
        run once. For a RepeatedWorker, this second function will run once the worker has been
        stopped manually. This secondary function can only take a single bool as a parameter. The
        worker will pass the success status of the main function as a parameter into this secondary
        function.

        :param function: the function object to be run when the worker exits
        :return: None
        &#34;&#34;&#34;

        self.finished.connect(function)

    def run(self) -&gt; None:
        &#34;&#34;&#34;
        The main function that will execute on another thread.

        Provides an error-handling wrapper around the main function, and signals the finishing
        state of the function when it exits.

        :return: None
        &#34;&#34;&#34;

        try:
            # Run the provided function
            self.function(*self.args)
            # Signal to any connected slots that the function ran successfully
            self.finished.emit(True)

        except Exception as e:
            # Signal to any connected slots that the function did not run successfully
            logging.error(e)
            self.finished.emit(False)


class SIMThread:

    def __init__(self, thread_worker: ThreadWorker, mode: str = &#34;single&#34;) -&gt; None:
        # Initialize a QThread to run the function on
        self.thread: QThread = QThread()

        # Mode that the ThreadWorker will be set up to run in
        if mode not in [&#34;single&#34;, &#34;signaled&#34;]:
            raise Exception(&#34;Unsupported mode passed into SIMThread constructor.&#34;)
        self.mode = mode

        # Store the provided worker
        self.worker: ThreadWorker = thread_worker

        # Start executing the worker on the second thread
        self.worker.moveToThread(self.thread)
        self.thread.started.connect(self.worker.run)
        if mode == &#34;single&#34;:
            self.worker.finished.connect(self.thread.quit)
            self.worker.finished.connect(self.worker.deleteLater)
            self.worker.finished.connect(self.thread.deleteLater)
        self.thread.start()

    def signal_worker(self) -&gt; None:
        &#34;&#34;&#34;
        Signals the thread worker to run the function again.

        If the SimThread is configured to run in &#34;signaled&#34; mode, then it&#39;s function will run
        every time that this function is called. If the SimThread is configured to run in &#34;single&#34;
        mode, then calling this function will have no effect

        :return:
        &#34;&#34;&#34;

        if self.mode == &#34;single&#34;:
            return
        self.thread.started.emit()

    def destroy_thread(self) -&gt; None:
        &#34;&#34;&#34;
        Function to clean up after a SIMThread is done being used.

        If called on a SIMThread that is configured for &#34;single&#34; mode, nothing will happen as the
        thread will take care of everything once it finishes execution. If called on a SIMThread that
        is configured for &#34;signaled&#34; mode, the thread will be killed and its worker and object will
        be finalized

        :return: None
        &#34;&#34;&#34;

        if self.mode == &#34;single&#34;:
            return
        self.thread.quit()
        self.worker.deleteLater()
        self.thread.deleteLater()


class HeadlessWindow(QMainWindow):
    &#34;&#34;&#34;
    QMainWindow that can be used when the Application is run in headless mode.

    A QApplication must be running for the QThreads to operate as expected. Therefore, when an Experiment
    script needs to be run without the main GUI (likely for testing purposes) this class needs to be instantiated
    so everything can run like it normally would with the GUI.
    &#34;&#34;&#34;
    def __init__(self, function: Callable, parent=None) -&gt; None:

        # Run the QMainWindow constructor
        super().__init__(parent)

        # Run the function that was passed in
        function()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="new_backend.Threading.HeadlessWindow"><code class="flex name class">
<span>class <span class="ident">HeadlessWindow</span></span>
<span>(</span><span>function:Â Callable, parent=None)</span>
</code></dt>
<dd>
<div class="desc"><p>QMainWindow that can be used when the Application is run in headless mode.</p>
<p>A QApplication must be running for the QThreads to operate as expected. Therefore, when an Experiment
script needs to be run without the main GUI (likely for testing purposes) this class needs to be instantiated
so everything can run like it normally would with the GUI.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class HeadlessWindow(QMainWindow):
    &#34;&#34;&#34;
    QMainWindow that can be used when the Application is run in headless mode.

    A QApplication must be running for the QThreads to operate as expected. Therefore, when an Experiment
    script needs to be run without the main GUI (likely for testing purposes) this class needs to be instantiated
    so everything can run like it normally would with the GUI.
    &#34;&#34;&#34;
    def __init__(self, function: Callable, parent=None) -&gt; None:

        # Run the QMainWindow constructor
        super().__init__(parent)

        # Run the function that was passed in
        function()</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtWidgets.QMainWindow</li>
<li>PyQt5.QtWidgets.QWidget</li>
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>PyQt5.QtGui.QPaintDevice</li>
<li>sip.simplewrapper</li>
</ul>
</dd>
<dt id="new_backend.Threading.SIMThread"><code class="flex name class">
<span>class <span class="ident">SIMThread</span></span>
<span>(</span><span>thread_worker:Â <a title="new_backend.Threading.ThreadWorker" href="#new_backend.Threading.ThreadWorker">ThreadWorker</a>, mode:Â strÂ =Â 'single')</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SIMThread:

    def __init__(self, thread_worker: ThreadWorker, mode: str = &#34;single&#34;) -&gt; None:
        # Initialize a QThread to run the function on
        self.thread: QThread = QThread()

        # Mode that the ThreadWorker will be set up to run in
        if mode not in [&#34;single&#34;, &#34;signaled&#34;]:
            raise Exception(&#34;Unsupported mode passed into SIMThread constructor.&#34;)
        self.mode = mode

        # Store the provided worker
        self.worker: ThreadWorker = thread_worker

        # Start executing the worker on the second thread
        self.worker.moveToThread(self.thread)
        self.thread.started.connect(self.worker.run)
        if mode == &#34;single&#34;:
            self.worker.finished.connect(self.thread.quit)
            self.worker.finished.connect(self.worker.deleteLater)
            self.worker.finished.connect(self.thread.deleteLater)
        self.thread.start()

    def signal_worker(self) -&gt; None:
        &#34;&#34;&#34;
        Signals the thread worker to run the function again.

        If the SimThread is configured to run in &#34;signaled&#34; mode, then it&#39;s function will run
        every time that this function is called. If the SimThread is configured to run in &#34;single&#34;
        mode, then calling this function will have no effect

        :return:
        &#34;&#34;&#34;

        if self.mode == &#34;single&#34;:
            return
        self.thread.started.emit()

    def destroy_thread(self) -&gt; None:
        &#34;&#34;&#34;
        Function to clean up after a SIMThread is done being used.

        If called on a SIMThread that is configured for &#34;single&#34; mode, nothing will happen as the
        thread will take care of everything once it finishes execution. If called on a SIMThread that
        is configured for &#34;signaled&#34; mode, the thread will be killed and its worker and object will
        be finalized

        :return: None
        &#34;&#34;&#34;

        if self.mode == &#34;single&#34;:
            return
        self.thread.quit()
        self.worker.deleteLater()
        self.thread.deleteLater()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="new_backend.Threading.SIMThread.destroy_thread"><code class="name flex">
<span>def <span class="ident">destroy_thread</span></span>(<span>self) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Function to clean up after a SIMThread is done being used.</p>
<p>If called on a SIMThread that is configured for "single" mode, nothing will happen as the
thread will take care of everything once it finishes execution. If called on a SIMThread that
is configured for "signaled" mode, the thread will be killed and its worker and object will
be finalized</p>
<p>:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def destroy_thread(self) -&gt; None:
    &#34;&#34;&#34;
    Function to clean up after a SIMThread is done being used.

    If called on a SIMThread that is configured for &#34;single&#34; mode, nothing will happen as the
    thread will take care of everything once it finishes execution. If called on a SIMThread that
    is configured for &#34;signaled&#34; mode, the thread will be killed and its worker and object will
    be finalized

    :return: None
    &#34;&#34;&#34;

    if self.mode == &#34;single&#34;:
        return
    self.thread.quit()
    self.worker.deleteLater()
    self.thread.deleteLater()</code></pre>
</details>
</dd>
<dt id="new_backend.Threading.SIMThread.signal_worker"><code class="name flex">
<span>def <span class="ident">signal_worker</span></span>(<span>self) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Signals the thread worker to run the function again.</p>
<p>If the SimThread is configured to run in "signaled" mode, then it's function will run
every time that this function is called. If the SimThread is configured to run in "single"
mode, then calling this function will have no effect</p>
<p>:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def signal_worker(self) -&gt; None:
    &#34;&#34;&#34;
    Signals the thread worker to run the function again.

    If the SimThread is configured to run in &#34;signaled&#34; mode, then it&#39;s function will run
    every time that this function is called. If the SimThread is configured to run in &#34;single&#34;
    mode, then calling this function will have no effect

    :return:
    &#34;&#34;&#34;

    if self.mode == &#34;single&#34;:
        return
    self.thread.started.emit()</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="new_backend.Threading.ThreadWorker"><code class="flex name class">
<span>class <span class="ident">ThreadWorker</span></span>
<span>(</span><span>function:Â Callable, *args)</span>
</code></dt>
<dd>
<div class="desc"><p>QObject(parent: QObject = None)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ThreadWorker(QObject):

    # The signals that can be connected to slots on another thread
    finished: pyqtSignal = pyqtSignal(bool)

    def __init__(self, function: Callable, *args):
        # Call the base QObject constructor
        super(ThreadWorker, self).__init__()

        # This function is the one that the Thread will execute when run
        self.function: Callable = function

        # Store the args that need to be passed to the called function
        self.args = args

    def call_when_finished(self, function: Callable) -&gt; None:
        &#34;&#34;&#34;
        Allows the user to specify a second function that will be called when the thread finishes.

        The function pass in here will be triggered on the main thread whenever this worker has
        finished. For a ThreadWorker, this second function will run once the main function has
        run once. For a RepeatedWorker, this second function will run once the worker has been
        stopped manually. This secondary function can only take a single bool as a parameter. The
        worker will pass the success status of the main function as a parameter into this secondary
        function.

        :param function: the function object to be run when the worker exits
        :return: None
        &#34;&#34;&#34;

        self.finished.connect(function)

    def run(self) -&gt; None:
        &#34;&#34;&#34;
        The main function that will execute on another thread.

        Provides an error-handling wrapper around the main function, and signals the finishing
        state of the function when it exits.

        :return: None
        &#34;&#34;&#34;

        try:
            # Run the provided function
            self.function(*self.args)
            # Signal to any connected slots that the function ran successfully
            self.finished.emit(True)

        except Exception as e:
            # Signal to any connected slots that the function did not run successfully
            logging.error(e)
            self.finished.emit(False)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>PyQt5.QtCore.QObject</li>
<li>sip.wrapper</li>
<li>sip.simplewrapper</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="new_backend.Threading.ThreadWorker.call_when_finished"><code class="name flex">
<span>def <span class="ident">call_when_finished</span></span>(<span>self, function:Â Callable) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>Allows the user to specify a second function that will be called when the thread finishes.</p>
<p>The function pass in here will be triggered on the main thread whenever this worker has
finished. For a ThreadWorker, this second function will run once the main function has
run once. For a RepeatedWorker, this second function will run once the worker has been
stopped manually. This secondary function can only take a single bool as a parameter. The
worker will pass the success status of the main function as a parameter into this secondary
function.</p>
<p>:param function: the function object to be run when the worker exits
:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def call_when_finished(self, function: Callable) -&gt; None:
    &#34;&#34;&#34;
    Allows the user to specify a second function that will be called when the thread finishes.

    The function pass in here will be triggered on the main thread whenever this worker has
    finished. For a ThreadWorker, this second function will run once the main function has
    run once. For a RepeatedWorker, this second function will run once the worker has been
    stopped manually. This secondary function can only take a single bool as a parameter. The
    worker will pass the success status of the main function as a parameter into this secondary
    function.

    :param function: the function object to be run when the worker exits
    :return: None
    &#34;&#34;&#34;

    self.finished.connect(function)</code></pre>
</details>
</dd>
<dt id="new_backend.Threading.ThreadWorker.finished"><code class="name flex">
<span>def <span class="ident">finished</span></span>(<span>...) â€‘>Â PyQt5.QtCore.pyqtSignal</span>
</code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt id="new_backend.Threading.ThreadWorker.run"><code class="name flex">
<span>def <span class="ident">run</span></span>(<span>self) â€‘>Â None</span>
</code></dt>
<dd>
<div class="desc"><p>The main function that will execute on another thread.</p>
<p>Provides an error-handling wrapper around the main function, and signals the finishing
state of the function when it exits.</p>
<p>:return: None</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run(self) -&gt; None:
    &#34;&#34;&#34;
    The main function that will execute on another thread.

    Provides an error-handling wrapper around the main function, and signals the finishing
    state of the function when it exits.

    :return: None
    &#34;&#34;&#34;

    try:
        # Run the provided function
        self.function(*self.args)
        # Signal to any connected slots that the function ran successfully
        self.finished.emit(True)

    except Exception as e:
        # Signal to any connected slots that the function did not run successfully
        logging.error(e)
        self.finished.emit(False)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="new_backend" href="index.html">new_backend</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="new_backend.Threading.HeadlessWindow" href="#new_backend.Threading.HeadlessWindow">HeadlessWindow</a></code></h4>
</li>
<li>
<h4><code><a title="new_backend.Threading.SIMThread" href="#new_backend.Threading.SIMThread">SIMThread</a></code></h4>
<ul class="">
<li><code><a title="new_backend.Threading.SIMThread.destroy_thread" href="#new_backend.Threading.SIMThread.destroy_thread">destroy_thread</a></code></li>
<li><code><a title="new_backend.Threading.SIMThread.signal_worker" href="#new_backend.Threading.SIMThread.signal_worker">signal_worker</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="new_backend.Threading.ThreadWorker" href="#new_backend.Threading.ThreadWorker">ThreadWorker</a></code></h4>
<ul class="">
<li><code><a title="new_backend.Threading.ThreadWorker.call_when_finished" href="#new_backend.Threading.ThreadWorker.call_when_finished">call_when_finished</a></code></li>
<li><code><a title="new_backend.Threading.ThreadWorker.finished" href="#new_backend.Threading.ThreadWorker.finished">finished</a></code></li>
<li><code><a title="new_backend.Threading.ThreadWorker.run" href="#new_backend.Threading.ThreadWorker.run">run</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>