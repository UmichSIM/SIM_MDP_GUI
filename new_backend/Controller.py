"""
Backend - Controller Class
Created on Tue February 15, 2022

Summary: The Controller class is a base class that implements control over the vehicles in the
    Simulation. Specific constants of the Controller can be specified in the constructor. This class
    provides the basic interface that all Controller classes MUST follow. Ego, Intersection, and
    Freeway controllers are derived from this base class

References:

Referenced By:

"""

# Local Imports
from ApiHelpers import ExperimentType
from Vehicle import Vehicle

# Library Imports
import carla
from typing import List, Tuple

# Global variable to define how far apart waypoints on the road network should be
WAYPOINT_SEPARATION = 10


class Controller:



    @staticmethod
    def update_control(current_vehicle: Vehicle) -> None:
        """
        Abstract function that dictates how a derived Controller class should update the Vehicles control.

        All derived controller classes must implement this method. The update_control method takes in a
        vehicle and determines what control parameters should be passed to it to update its acceleration
        and steering in the Carla simulation. This function will call apply_control on the current
        vehicle to steer the vehicle in the correct direction.

        :param current_vehicle: the Vehicle object to which updated control needs to be applied
        :param mode: a string representing whether the Vehicle should target a certain "speed" or a
        :return: None
        """
        pass

    @staticmethod
    def generate_path(current_vehicle: Vehicle, starting_point: carla.Waypoint, ending_point: carla.Waypoint) -> None:
        """
        Calculates the shortest trajectory between the starting endpoint and ending waypoint of the Vehicle's route.

        Uses Djikstra's algorithm to determine the shortest path between the starting waypoint and
        the ending waypoint. All paths will follow Carla's autogenerated waypoints that define the
        valid road network. The path is guaranteed to take the shortest number of jumps between waypoints,
        however there is no guarantee that the path will be the shortest in terms of absolute distance.

        :param current_vehicle: the Vehicle object that the path needs to be generated for
        :param starting_point: the carla.Waypoint object that the vehicle will be starting at
        :param ending_point: the carla.Waypoint object that the vehicle will be ending at
        :return: None
        """

        # List of transforms that comprise the path
        waypoints: List[carla.Transform] = []

        # List of tuples containing each explored waypoint and the index of their previous waypoint along the path
        explored_list: List[Tuple[carla.Waypoint, int]] = []

        # List of tuples containing each waypoint that still needs to be explored along with the index of
        # the waypoint that added them to this list
        potential_list: List[Tuple[carla.Waypoint, int]] = []

        # Add the initial point to the potential_list
        potential_list.append((starting_point, -1))

        # Main Djikstra's loop
        while True:

            # Grab the current waypoint and previous index
            current_waypoint, current_previous_index = potential_list.pop(0)

            # Add them to the explored list
            explored_list.append((current_waypoint, current_previous_index))

            # If the search is over, backtrack to build the path
            if Controller.end_of_search(current_waypoint, ending_point):
                waypoints = Controller.backtrack_path(explored_list)
                current_vehicle.waypoints = waypoints
                return

            # Check all the potential next waypoints and add them to the potential list
            # if they haven't already been explored
            potential_new_waypoints = Controller.get_next_waypoints(current_waypoint)
            already_explored_waypoint_ids = [x[0].id for x in explored_list]
            for potential_new_waypoint in potential_new_waypoints:
                if potential_new_waypoint.id not in already_explored_waypoint_ids:
                    potential_list.append((potential_new_waypoint, len(explored_list) - 1))

            if len(potential_list) == 0:
                raise Exception(f"Unable to find path between waypoints {starting_point.id} and {ending_point.id}")


    @staticmethod
    def obey_traffic_light(current_vehicle: Vehicle) -> (bool, carla.VehicleControl):
        """
        Determines if the Vehicle needs to change its control to obey a traffic light.

        Checks if the Vehicle is currently being affected by a traffic light, and
        provides a new carla.VehicleControl object that will allow the Vehicle to
        obey the light. Designed to be called either within or after update_control.

        :param current_vehicle: the Vehicle object that will be checked for traffic lights
        :return: a tuple of (bool, carla.VehicleControl). The first element will be True if the Vehicle
                 is being affected by a traffic light. If True, the second element will contain a
                 new carla.VehicleControl that should be applied to the Vehicle.
        """
        pass

    @staticmethod
    def avoid_collisions(current_vehicle: Vehicle) -> (bool, carla.VehicleControl):
        """
        Determines if the Vehicle needs to change its control to avoid a collision.

        Checks if the Vehicle is nearing a collision with another nearby Vehicle, and
        provides a new carla.VehicleControl object that will allow the Vehicle to avoid the
        collision. Designed to be called either within or after update_control.

        :param current_vehicle: the Vehicle object that will be checked for near collisions
        :return: a tuple of (bool, carla.VehicleControl). The first element will be True if the Vehicle
                 needs to avoid a collision. If True, the second element will contain a
                 new carla.VehicleControl that should be applied to the Vehicle.
        """
        pass

    @staticmethod
    def obey_safety_distance(current_vehicle: Vehicle) -> (bool, carla.VehicleControl):
        """
        Determines if the Vehicle needs to change its control to obey its safety distance.

        Checks if the Vehicle is following too closely behind the Vehicle directly in front
        of it, and provides a new carla.VehicleControl object that will allow the Vehicle to
        move back to the safety distance. Designed to be called within update_control.

        :param current_vehicle: the Vehicle object that will be checked for safety distance
        :return: a tuple of (bool, carla.VehicleControl). The first element will be True if the Vehicle
                 needs adjust to meet its safety distance. If True, the second element will contain a
                 new carla.VehicleControl that should be applied to the Vehicle.
        """
        pass

    @staticmethod
    def end_of_search(current_waypoint: carla.Waypoint, ending_waypoint: carla.Waypoint) -> bool:
        """
        Determines if the Djikstra search has successfully arrived at it's destination point.

        To finish the search, the current waypoint must be less than half of WAYPOINT_SEPARATION
        away from the ending waypoint

        :param current_waypoint: a carla.Waypoint representing the current waypoint in the search
        :param ending_waypoint: a carla.Waypoint representing the ending waypoint in the search
        :return: a bool representing if the search is finished
        """

        current_location = current_waypoint.transform.location
        ending_location = ending_waypoint.transform.location
        separation = current_location.distance(ending_location)
        if separation < WAYPOINT_SEPARATION / 2:
            return True
        return False

    @staticmethod
    def backtrack_path(explored_list: List[Tuple[carla.Waypoint, int]]) -> List[carla.Transform]:
        """
        Backtracks the explored path to build the shortest path from the initial point to the final destination.

        :param explored_list: a List of Tuples where the first element is a carla.Waypoint object
                              and the second element is the list index of the ancestor waypoint
        :return: a list of carla.Transforms representing the completed path
        """

        # Initialize the path and the ending locations
        path: List[carla.Waypoint] = []
        current_waypoint, current_index = explored_list[-1]

        # Continue backtracking until the first waypoint is reached
        while current_index != -1:
            path.append(current_waypoint.transform)
            current_waypoint, current_index = explored_list[current_index]

        return path[::-1]

    @staticmethod
    def get_next_waypoints(current_waypoint: carla.Waypoint) -> List[carla.Waypoint]:
        """
        Gets a list of all the possible next waypoints from the current waypoint

        :param current_waypoint: a carla.Waypoint representing the current waypoint
        :return: a List of carla.Waypoints
        """

        # Get all the possible next waypoints
        new_potential_waypoints: List[carla.Waypoint] = current_waypoint.next(WAYPOINT_SEPARATION)

        # Also add additional waypoints if the current waypoint is an intersection
        if current_waypoint.is_junction:
            junction_points = current_waypoint.get_junction().get_waypoints(carla.LaneType.Any)
            for pair in junction_points:
                for point in pair:
                    new_potential_waypoints.append(point)

        return new_potential_waypoints
