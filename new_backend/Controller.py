"""
Backend - Controller Class
Created on Tue February 15, 2022

Summary: The Controller class is a base class that implements control over the vehicles in the
    Simulation. Specific constants of the Controller can be specified in the constructor. This class
    provides the basic interface that all Controller classes MUST follow. Ego, Intersection, and
    Freeway controllers are derived from this base class

References:

Referenced By:

"""

# Local Imports
from Vehicle import Vehicle

# Library Imports
import carla
from typing import List


class Controller:

    @staticmethod
    def update_control(current_vehicle: Vehicle, mode: str, avoid_collisions: bool = False) -> carla.VehicleControl:
        """
        Abstract function that dictates how a derived Controller class should update the Vehicles control.

        All derived controller classes must implement this method. The update_control method takes in a
        vehicle and determines what control parameters should be passed to it to update its acceleration
        and steering in the Carla simulation. This function will return a carla.VehicleControl object
        that will be passed into the Vehicle's apply_control method.

        :param current_vehicle: the Vehicle object to which updated control needs to be applied
        :param mode: a string representing whether the Vehicle should target a certain "speed" or a
                     certain "distance" behind the vehicle it is following
        :param avoid_collisions: whether the Vehicle should actively avoid collisions with nearby vehicles
        :return: a carla.VehicleControl object representing the acceleration and steering that should
                 be applied to the current_vehicle
        """
        pass

    @staticmethod
    def generate_path(current_vehicle: Vehicle, starting_point: carla.Waypoint, ending_point: carla.Waypoint) -> List[carla.Transform]:
        """
        Calculates the shortest trajectory between the starting endpoint and ending waypoint of the Vehicle's route.

        Uses Djikstra's algorithm to determine the shortest path between the starting waypoint and
        the ending waypoint. All paths will follow Carla's autogenerated waypoints that define the
        valid road network. The path is guaranteed to take the shortest number of jumps between waypoints,
        however there is no guarantee that the path will be the shortest in terms of absolute distance.

        :param current_vehicle: the Vehicle object that the path needs to be generated for
        :param starting_point: the carla.Waypoint object that the vehicle will be starting at
        :param ending_point: the carla.Waypoint object that the vehicle will be ending at
        :return: a List containing the carla.Transforms that define the entire path
        """
        pass

    @staticmethod
    def obey_traffic_light(current_vehicle: Vehicle) -> (bool, carla.VehicleControl):
        """
        Determines if the Vehicle needs to change its control to obey a traffic light.

        Checks if the Vehicle is currently being affected by a traffic light, and
        provides a new carla.VehicleControl object that will allow the Vehicle to
        obey the light. Designed to be called either within or after update_control.

        :param current_vehicle: the Vehicle object that will be checked for traffic lights
        :return: a tuple of (bool, carla.VehicleControl). The first element will be True if the Vehicle
                 is being affected by a traffic light. If True, the second element will contain a
                 new carla.VehicleControl that should be applied to the Vehicle.
        """
        pass

    @staticmethod
    def avoid_collisions(current_vehicle: Vehicle) -> (bool, carla.VehicleControl):
        """
        Determines if the Vehicle needs to change its control to avoid a collision.

        Checks if the Vehicle is nearing a collision with another nearby Vehicle, and
        provides a new carla.VehicleControl object that will allow the Vehicle to avoid the
        collision. Designed to be called either within or after update_control.

        :param current_vehicle: the Vehicle object that will be checked for near collisions
        :return: a tuple of (bool, carla.VehicleControl). The first element will be True if the Vehicle
                 needs to avoid a collision. If True, the second element will contain a
                 new carla.VehicleControl that should be applied to the Vehicle.
        """
        pass

    @staticmethod
    def obey_safety_distance(current_vehicle: Vehicle) -> (bool, carla.VehicleControl):
        """
        Determines if the Vehicle needs to change its control to obey its safety distance.

        Checks if the Vehicle is following too closely behind the Vehicle directly in front
        of it, and provides a new carla.VehicleControl object that will allow the Vehicle to
        move back to the safety distance. Designed to be called within update_control.

        :param current_vehicle: the Vehicle object that will be checked for safety distance
        :return: a tuple of (bool, carla.VehicleControl). The first element will be True if the Vehicle
                 needs adjust to meet its safety distance. If True, the second element will contain a
                 new carla.VehicleControl that should be applied to the Vehicle.
        """
        pass